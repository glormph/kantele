{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../../frontend/analysis/src/App.svelte"
  ],
  "sourcesContent": [
    "<script>\n\nimport { onMount } from 'svelte';\nimport { flashtime } from '../../util.js'\nimport { getJSON, postJSON } from '../../datasets/src/funcJSON.js'\n\nlet notif = {errors: {}, messages: {}, links: {}};\nlet loadingItems = false;\n\nlet runButtonActive = true;\nlet postingAnalysis = false;\n\nlet allwfs = {};\nlet wf = false;\nlet wforder = [];\nlet dsets = {};\n\n/* API v1:\n- no mixed isobaric -ok\n- no mixed instruments -ok\n- mixed dtype is ok i guess, but stupid -ok\n- remove invisible flags (deqmspossible, nf1901, nf-coremarker) - ok\n- isobaric passing to pipeline in a certain way (flags, sets etc) -ok?\n- predefined files in old version - ok\n\n- task change nf version\n\nAPI v2\n- version switcher for new version - FIXME\n- isobaric/instrument -> mzmldef\n- mods etc?\n- multiple DBs\n- luciphor PTMs\n\nTest\n- normal hirief\n- labelfree?\n- filesaresets (eg LG)\n- labelcheck\n- 6FT, vardb\n- nf-core version config FIXME task change\n*/\n\n// API v1 instype is not important in v2\n\nlet isoquants = {};\nlet mediansweep = false;\n\nlet config = {\n  wfid: false,\n  wfversion: false,\n  analysisname: '',\n  flags: [],\n  fileparams: {},\n  v1: false,\n  v2: false,\n  version_dep: {\n    v1: {\n      instype: false,\n      dtype: false,\n    }\n  },\n}\nlet matchedFr = {};\nlet frregex = {};\n\nfunction validate() {\n  notif = {errors: {}, messages: {}, links: {}};\n  const charRe = RegExp('^[a-z0-9_-]+$', 'i');\n  if (!config.analysisname) {\n\t  notif.errors['Analysisname must be filled in'] = 1;\n\t} else if (!charRe.test(config.analysisname)) {\n\t\tnotif.errors['Analysisname may only contain a-z 0-9 _ -'] = 1;\n\t}\n\tif (!config.wfid) {\n\t\tnotif.errors['You must select a workflow'] = 1;\n\t}\n  if (!config.wfversion) {\n\t\tnotif.errors['You must select a workflow version'] = 1;\n\t}\n  Object.values(dsets).forEach(ds => {\n    if (config.v1 && config.version_dep.v1.dtype.toLowerCase() !== 'labelcheck' && !ds.filesaresets && !ds.setname) {\n\t\t\tnotif.errors[`Dataset ${ds.proj} - ${ds.exp} - ${ds.run} needs to have a set name`] = 1;\n    } else if (ds.filesaresets) {\n      if (ds.files.filter(fn => !fn.setname).length) {\n\t\t\t  notif.errors[`File ${fn.name} needs to have a setname`] = 1;\n\t\t\t}\n    } else if (ds.setname && !charRe.test(ds.setname)) {\n\t\t\tnotif.errors[`Dataset ${ds.proj} - ${ds.exp} - ${ds.run} needs to have another set name: only a-z 0-9 _ are allowed`] = 1;\n\t\t}\n\t});\n  Object.entries(isoquants).forEach(([sname, isoq]) => {\n    Object.entries(isoq.samplegroups).forEach(([ch, sgroup]) => {\n      if (sgroup && !charRe.test(sgroup)) {\n        notif.errors[`Incorrect sample group name for set ${sname}, channel ${ch}, only A-Z a-z 0-9 _ are allowed`] =1; \n      }\n    })\n  })\n  return Object.keys(notif.errors).length === 0;\n}\n\n\nasync function runAnalysis() {\n  if (!validate()) {\n  \treturn false;\n  }\n  runButtonActive = false;\n  postingAnalysis = true;\n  notif.messages['Validated data'] = 1;\n  //let fns = Object.assign({}, config.fileparams)\n  let fns = Object.fromEntries(Object.entries(config.fileparams).filter(([k,v]) => v))\n  wf.fixedfileparams.forEach(fn => {\n    fns[fn.nf] = fn.id\n  })\n  let setnames = {};\n  Object.values(dsets).filter(ds => ds.filesaresets).forEach(ds => {\n    Object.assign(setnames, Object.fromEntries(ds.files.map(fn => [fn.id, fn.setname])));\n  });\n  Object.values(dsets).filter(ds => !ds.filesaresets).forEach(ds => {\n    Object.assign(setnames, Object.fromEntries(ds.files.map(fn => [fn.id, ds.setname])));\n  });\n\n  const fractions = Object.fromEntries(Object.values(dsets).flatMap(ds => ds.files.map(fn => [fn.id, fn.fr])));\n\n  notif.messages[`${Object.keys(setnames).length} set(s) found`] = 1;\n  notif.messages[`Using ${Object.keys(dsets).length} dataset(s)`] = 1;\n  notif.messages[`${Object.keys(fns).length} other inputfiles found`];\n  let post = { \n    setnames: setnames,\n    dsids: Object.keys(dsets),\n    fractions: fractions,\n    files: fns,\n    wfid: config.wfid,\n    nfwfvid: config.wfversion.id,\n    analysisname: `${allwfs[config.wfid].wftype}_${config.analysisname}`,\n    strips: {},\n    params: {flags: config.flags},\n  };\n  if (config.v1) {\n    post.params.inst = ['--instrument', config.version_dep.v1.instype];\n    post.params.quant = config.version_dep.v1.qtype === 'labelfree' ? [] : ['--isobaric', config.version_dep.v1.qtype];\n  }\n  // HiRIEF\n  Object.values(dsets).forEach(ds => {\n    post.strips[ds.id] = ds.hr ? ds.hr : ds.prefrac ? 'unknown_plate' : false\n  })\n  // general denoms = {set1: [126, 127], set2: [128, 129]}\n  let denoms = Object.fromEntries(Object.entries(isoquants).map(([sname, isoq]) => \n    [sname, Object.entries(isoq.denoms).filter(([ch, val]) => val).map(([ch, val]) => ch)]\n   ))\n  // API v1: denoms: 'set1:126:127 set2:128:129'\n  denoms = Object.entries(denoms).filter(([sn, chs]) => chs.length > 0).map(([sname, chs]) => `${sname}:${chs.join(':')}`).join(' ')\n  if (denoms.length > 0 && !mediansweep) {\n    post.params.denoms = ['--denoms', denoms];\n  }\n\n  // sampletable [[ch, sname, groupname], [ch2, sname, samplename, groupname], ...]\n  // we can push sampletables on ANY workflow as nextflow will ignore non-params\n  let sampletable = Object.entries(isoquants).flatMap(([sname, isoq]) => \n    Object.entries(isoq.channels).map(([ch, sample]) => [ch, sname, sample, isoq.samplegroups[ch]]).sort((a, b) => {\n\t  return a[0].replace('N', 'A') > b[0].replace('N', 'A')\n    })\n  );\n  post.sampletable = sampletable.map(row => row.slice(0, 3).concat(row[3] ? row[3] : 'X__POOL'));\n   \n  // Post the payload\n  notif.messages[`Posting analysis job for ${this.analysisname}`] = 1;\n  const resp = await postJSON('/analysis/run/', post);\n  if (resp.error) {\n    notif.errors[resp.error] = 1;\n    if ('link' in resp) {\n      notif.links[resp.link] = 1;\n    }\n  } else {\n\t  window.location.href = '/?tab=searches';\n\t}\n  postingAnalysis = false;\n  runButtonActive = true;\n}\n\n\nasync function fetchWorkflow() {\n  let url = new URL('/analysis/workflow', document.location)\n  const params = {dsids: dsids.join(','), wfvid: config.wfversion.id};\n  url.search = new URLSearchParams(params).toString();\n  const result = await getJSON(url);\n  loadingItems = true;\n  if ('error' in result) {\n    const msg = `While fetching workflow versions, encountered: ${result.error}`;\n    notif.errors[msg] = 1;\n    setTimeout(function(msg) { notif.errors[msg] = 0 } , flashtime, msg);\n  } else {\n    wf = result['wf'];\n    config.v1 = wf.analysisapi === 1;\n    config.v2 = wf.analysisapi === 2;\n  }\n  fetchDatasetDetails();\n}\n\nasync function fetchAllWorkflows() {\n  let url = new URL('/analysis/workflows', document.location)\n  const result = await getJSON(url);\n  loadingItems = true;\n  if ('error' in result) {\n    const msg = `While fetching workflows, encountered: ${result.error}`;\n    notif.errors[msg] = 1;\n    setTimeout(function(msg) { notif.errors[msg] = 0 } , flashtime, msg);\n  } else {\n    allwfs = result.allwfs;\n    wforder = result.order;\n  }\n}\n\nasync function fetchDatasetDetails() {\n  let url = new URL('/analysis/dsets/', document.location)\n  const params = {dsids: dsids.join(',')};\n  url.search = new URLSearchParams(params).toString();\n  const result = await getJSON(url);\n  if (result.error) {\n    const msg = result.errmsg;\n    notif.errors[msg] = 1;\n    setTimeout(function(msg) { notif.errors[msg] = 0 } , flashtime, msg);\n  } else {\n    dsets = result.dsets;\n    Object.entries(dsets).filter(x=>x[1].prefrac).forEach(x=>matchFractions(dsets[x[0]]));\n    Object.entries(dsets).forEach(ds => {\n      ds.filesaresets = false;\n      ds.setname = '';\n    })\n    // API v1 stuff\n    const dtypes = new Set(Object.values(dsets).map(ds => ds.dtype.toLowerCase()));\n    config.version_dep.v1.dtype = dtypes.size > 1 ? 'mixed' : dtypes.keys().next().value;\n    const qtypes = new Set(Object.values(dsets).map(ds => ds.details.qtypeshort));\n    if (config.v1 && qtypes.size > 1) {\n      notif.errors['Mixed quant types detected, cannot use those in single run, use more advanced pipeline version'] = 1;\n    } else {\n      config.version_dep.v1.qtype = qtypes.keys().next().value;\n    }\n    const instypes = new Set(Object.values(dsets).flatMap(ds => ds.details.instrument_types).map(x => x.toLowerCase()));\n    if (config.v1 && instypes.size> 1) {\n      notif.errors['Mixed instrument types detected, cannot use those in single run, use more advanced pipeline version'] = 1;\n    } else {\n      config.version_dep.v1.instype = instypes.keys().next().value;\n    }\n  }\n}\n\nfunction matchFractions(ds) {\n  let allfrs = new Set();\n  for (let fn of ds.files) {\n    const match = fn.name.match(RegExp(frregex[ds.id]));\n    if (match) {\n      fn.fr = match[1];\n      allfrs.add(match[1]);\n    } else {\n      fn.fr = 'NA';\n    }\n  }\n\tmatchedFr[ds.id] = allfrs.size;\n}\n\nfunction sortChannels(channels) {\n  return Object.entries(channels).sort((a,b) => {\n\t  return a[0].replace('N', 'A') > b[0].replace('N', 'A')\n  }).map(x => {return {ch: x[0], sample: x[1]}});\n}\n\nfunction updateIsoquant() {\n  // Add new set things if necessary\n  Object.values(dsets).forEach(ds => {\n    if (!(ds.setname in isoquants)) {\n      isoquants[ds.setname] = {\n        channels: ds.details.channels,\n        samplegroups: Object.fromEntries(Object.keys(ds.details.channels).map(x => [x, ''])),\n        denoms: Object.fromEntries(Object.keys(ds.details.channels).map(x => [x, false]))\n      };\n    }\n  });\n  // Remove old sets from isoquants if necessary\n  const dset_sets = new Set(Object.values(dsets).map(ds => ds.setname));\n  Object.keys(isoquants).filter(x => !(dset_sets.has(x))).forEach(x => {\n    delete(isoquants[x])\n  });\n}\n\n\nonMount(async() => {\n  frregex = Object.fromEntries(dsids.map(dsid => [dsid, '.*fr([0-9]+).*mzML$']));\n  fetchAllWorkflows();\n})\n</script>\n\n<style>\n.errormsg {\n  position: -webkit-sticky;\n  position: sticky;\n  top: 20px;\n  z-index: 50000;\n}\n</style>\n\n<div class=\"errormsg\">\n{#if Object.values(notif.errors).some(x => x === 1)}\n<div class=\"notification is-danger is-light\"> \n    {#each Object.entries(notif.errors).filter(x => x[1] == 1).map(x=>x[0]) as error}\n    <div>{error}</div>\n    {/each}\n</div>\n{/if}\n\n{#if Object.values(notif.links).some(x => x === 1)}\n<div class=\"notification is-danger is-light errormsg\"> \n    {#each Object.entries(notif.links).filter(x => x[1] == 1).map(x=>x[0]) as link}\n    <div>Click here: <a target=\"_blank\" href={link}>here</a></div>\n    {/each}\n</div>\n{/if}\n\n{#if Object.values(notif.messages).some(x => x === 1)}\n<div class=\"notification is-success is-light errormsg\"> \n    {#each Object.entries(notif.messages).filter(x => x[1] == 1).map(x=>x[0]) as message}\n    <div>{message}</div>\n    {/each}\n</div>\n{/if}\n</div>\n\n<div class=\"content\">\n\t<div class=\"title is-5\">Analysis </div>\n\t<div class=\"field is-horizontal\">\n    <div class=\"field-label is-normal\">\n      <label class=\"label\">Workflow:</label>\n    </div>\n    <div class=\"field-body\">\n      <div class=\"field\">\n        <div class=\"select\">\n          <select bind:value={config.wfid} on:change={e => wf = config.wfversion = false}>\n            <option disabled value={false}>Select workflow</option>\n            {#each wforder as wfid}\n            <option value={wfid}>{allwfs[wfid].name} </option>\n            {/each}\n          </select>\n        </div>\n      </div>\n    </div>\n    <div class=\"field-label is-normal\">\n      <label class=\"label\">Workflow version:</label>\n    </div>\n    <div class=\"field-body\">\n      <div class=\"field\">\n        <div class=\"select\" on:change={fetchWorkflow}>\n          <select bind:value={config.wfversion}>\n            <option disabled value={false}>Select workflow version</option>\n            {#if config.wfid}\n            {#each allwfs[config.wfid].versions as wfv}\n            <option value={wfv}>\n              {#if wfv.latest}\n              <span>LATEST: </span>\n              {/if}\n              {wfv.date} -- {wfv.name}\n            </option>\n            {/each}\n            {/if}\n          </select>\n        </div>\n      </div>\n    </div>\n\t</div>\n\n\n  {#if wf}\n\t<div class=\"field\">\n    <input type=\"text\" class=\"input\" bind:value={config.analysisname} placeholder=\"Please enter analysis name\">\n    <div>Full name will be <code>{allwfs[config.wfid].wftype}_{config.analysisname}</code>\n    This will be the folder name for the output and prefixed to the output filenames\n    </div>\n\t</div>\n\n  <!-------------------------- ############### API v1? -->\n\t<div class=\"title is-5\">Datasets</div>\n  {#each Object.values(dsets) as ds}\n  <div class=\"box\">\n    {#if ds.dtype.toLowerCase() === 'labelcheck'}\n    <span class=\"has-text-primary\">{ds.proj} // Labelcheck // {ds.run} // {ds.details.qtype} // {ds.details.instruments.join(',')}</span>\n    {:else}\n\t\t<div class=\"columns\">\n\t\t  <div class=\"column\">\n        {#if !ds.prefrac}\n        <input type=\"checkbox\" bind:checked={ds.filesaresets}>\n\t\t\t\t<label class=\"checkbox\">Each file is a different sample</label>\n        {/if}\n        {#if !ds.filesaresets}\n\t\t\t  <div class=\"field\">\n          <input type=\"text\" class=\"input\" placeholder=\"Name of set\" bind:value={ds.setname} on:change={updateIsoquant}>\n\t\t\t  </div>\n        {/if}\n\t\t\t  <div class=\"subtitle is-6 has-text-primary\">\n          <span>{ds.proj} // {ds.exp} // {ds.run} //</span>\n          {#if !ds.prefrac}\n          <span>{ds.dtype}</span>\n          {:else if ds.hr}\n          <span>{ds.hr}</span>\n          {:else}\n          <span>{ds.prefrac}</span>\n          {/if}\n\t\t\t  </div>\n\t\t\t  <div class=\"subtitle is-6\">\n\t\t\t\t  <span>{ds.details.qtype} </span>\n          {#each Object.entries(ds.details.nrstoredfiles) as sf}\n\t\t      <span> // {sf[1]} {sf[0]} files </span>\n          {/each}\n\t\t\t\t  <span>// {ds.details.instruments.join(', ')} </span>\n\t\t\t  </div>\n        {#if ds.details.nrstoredfiles.refined_mzML}\n\t\t\t  <div class=\"subtitle is-6\"><strong>Enforcing use of refined mzML(s)</strong></div>\n        {/if}\n\t\t\t</div>\n\t\t\t<div class=\"column\">\n        {#if ds.prefrac}\n        <div class=\"field\">\n\t\t\t\t\t<label class=\"label\">Regex for fraction detection</label>\n          <input type=\"text\" class=\"input\" on:change={e => matchFractions(ds)} bind:value={frregex[ds.id]}>\n\t\t\t\t</div>\n\t\t\t\t<span>{matchedFr[ds.id]} fractions matched</span>\n        {/if}\n\t\t\t</div>\n\t\t</div>\n    {#if ds.filesaresets}\n    {#each ds.files as fn}\n    <div class=\"columns\">\n\t\t  <div class=\"column\">{fn.name}</div>\n\t\t  <div class=\"column\">\n        <input type=\"text\" class=\"input\" bind:value={fn.setname} placeholder={fn.sample}>\n\t\t\t</div>\n\t\t</div>\n    {/each}\n    {/if}\n    {/if}\n  </div>\n  {/each}\n\n  {#if Object.keys(isoquants).length}\n  <div class=\"box\">\n\t\t<div class=\"title is-5\">Isobaric quantification</div>\n    {#if Object.keys(isoquants).length === 1}\n    <div class=\"field\">\n      <input type=\"checkbox\" bind:checked={mediansweep}>\n      <label class=\"checkbox\">Use median sweeping (no predefined denominators)\n        <span class=\"icon is-small\">\n          <a title=\"Pick median denominator per PSM, only for single-set analyses\"><i class=\"fa fa-question-circle\"></i></a>\n        </span>\n      </label>\n    </div>\n    {/if}\n    {#each Object.entries(isoquants) as isoq}\n    <div class=\"has-text-primary title is-6\">Set: {isoq[0]}</div>\n    <div class=\"columns\">\n      <div class=\"column is-three-quarters\">\n        <table class=\"table is-striped is-narrow\">\n          <thead>\n            <tr>\n              {#if !mediansweep}\n              <th>Denominator</th>\n              {:else}\n              <th><del>Denominator</del></th>\n              {/if}\n              <th>Channel</th>\n              <th>Sample name</th>\n              <th>Sample group \n                <span class=\"icon is-small\">\n                  <a title=\"For DEqMS and PCA plots\"><i class=\"fa fa-question-circle\"></i></a>\n                </span>\n                LEAVE EMPTY FOR INTERNAL STANDARDS!</th>\n      \t\t  </tr>\n          </thead>\n          <tbody>\n            {#each sortChannels(isoq[1].channels) as {ch, sample}}\n            <tr>\n              <td>\n                {#if !mediansweep}\n                <input type=\"checkbox\" bind:checked={isoq[1].denoms[ch]} />\n                {/if}\n              </td>\n              <td>{ch}</td>\n              <td>{sample}</td>\n              <td>\n                <input type=\"text\" class=\"input\" bind:value={isoq[1].samplegroups[ch]} placeholder=\"Sample group or empty (e.g. CTRL, TREAT)\">\n              </td>\n      \t\t  </tr>\n            {/each}\n          </tbody>\n        </table>\n      </div>\n    </div>\n    {/each}\n  </div>\n  {/if}\n  <!---------- ##################### -->\n\n  <div class=\"box\">\n    <div class=\"title is-5\">Workflow parameters</div>\n    {#each Object.entries(wf.flags) as flag}\n    <div>\n      <input value={flag[0]} bind:group={config.flags} type=\"checkbox\">\n      <label class=\"checkbox\">{flag[1]}</label>: <code>{flag[0]}</code>\n    </div>\n    {/each}\n    {#if !('flags' in wf) || !(Object.keys(wf.flags).length)}\n    <div>No parameters for this workflow</div>\n    {/if}\n\t</div>\n\n  <div class=\"box\">\n    <div class=\"title is-5\">Input files</div>\n    {#each wf.fileparams as filep}\n    <div class=\"field\">\n      <label class=\"label\">{filep.name}</label>\n      <div class=\"select\">\n        <select bind:value={config.fileparams[filep.nf]}>\n          <option disabled value=\"\">Please select one</option>\n          <option value=\"\">Do not use this parameter</option>\n          {#if filep.ftype in wf.libfiles}\n          {#each wf.libfiles[filep.ftype] as libfn}\n          <option value={libfn.id}>{libfn.name} -- {libfn.desc}</option>\n          {/each}\n          {/if}\n          {#if filep.allow_resultfile}\n          {#each wf.prev_resultfiles as resfile}\n          <option value={resfile.id}>{resfile.analysisname} -- {resfile.analysisdate} -- {resfile.name}</option>\n          {/each}\n          {/if}\n        </select>\n      </div>\n    </div>\n    {/each}\n\t</div>\n\n  {#if wf.fixedfileparams.length}\n\t<div class=\"box\">\n    <div class=\"title is-5\">Predefined files</div>\n    {#each wf.fixedfileparams as ffilep}\n    <div class=\"field\">\n      <label class=\"label\">{ffilep.name}</label>\n      <div class=\"select\" >\n        <select>\n          <option disabled value=\"\">Fixed selection</option>\n          <option>{ffilep.fn} -- {ffilep.desc}</option>\n        </select>\n      </div>\n    </div>\n    {/each}\n  </div>\n  {/if}\n\n  {#if runButtonActive}\n  <a class=\"button is-primary\" on:click={runAnalysis}>Run analysis</a>\n  {:else if postingAnalysis}\n\t<a class=\"button is-primary is-loading\">Run analysis</a>\n  {:else}\n\t<a class=\"button is-primary\" disabled>Run analysis</a>\n  {/if}\n\n  {/if} \n</div>\n"
  ],
  "names": [],
  "mappings": "AAqSA,SAAS,cAAC,CAAC,AACT,QAAQ,CAAE,cAAc,CACxB,QAAQ,CAAE,MAAM,CAChB,GAAG,CAAE,IAAI,CACT,OAAO,CAAE,KAAK,AAChB,CAAC"
}