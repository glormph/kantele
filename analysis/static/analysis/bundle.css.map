{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../../frontend/analysis/src/App.svelte"
  ],
  "sourcesContent": [
    "<script>\n/* TODO\n- loadable/edit analysis\n- button store, button store+run\n- click-removable datasets ?\n- \n*/\n\nimport { onMount } from 'svelte';\nimport { flashtime } from '../../util.js'\nimport { getJSON, postJSON } from '../../datasets/src/funcJSON.js'\nimport DynamicSelect from '../../datasets/src/DynamicSelect.svelte';\n\nlet notif = {errors: {}, messages: {}, links: {}};\nlet loadingItems = false;\n\nlet runButtonActive = true;\nlet postingAnalysis = false;\n\nlet analysis_id = existing_analysis ? existing_analysis.analysis_id : false;\nlet allwfs = {};\nlet wf = false;\nlet wforder = [];\nlet dsets = {};\n\nlet libfiles = {};\nlet libfnorder = [];\nlet fetched_resultfiles = [];\nlet prev_resultfiles = [];\nlet resfn_arr = [];\nlet resultfiles = {}\nlet resultfnorder = [];\n\nlet base_analysis = {\n  isComplement: false,\n  selected: false,\n  typedname: '',\n  fetched: {},\n  resultfiles: [],\n}\n\nlet adding_analysis = {\n  selected: false,\n  typedname: '',\n  fetched: {},\n}\n\nlet added_analyses_order = [];\nlet added_results = {};\nif (existing_analysis && existing_analysis.added_results) {\n  added_results = existing_analysis.added_results;\n  added_analyses_order = Object.keys(existing_analysis.added_results);\n}\n\n$: {\n  fetched_resultfiles = added_analyses_order.flatMap(x => added_results[x].fns);\n  resfn_arr = fetched_resultfiles.concat(base_analysis.resultfiles).concat(prev_resultfiles);\n  resultfiles = Object.fromEntries(resfn_arr.map(x=> [x.id, x]));\n  resultfnorder = resfn_arr.map(x => x.id);\n}\n\n/*\nNF workflow API v1:\n- no mixed isobaric\n- no mixed instruments\n- mixed dtype is ok i guess, but stupid\n- predefined files exist\n- isobaric spec as --isobaric tmt10plex --denoms set1:126 set2:127N\n \nNF workflow API v2:\n- mods / locptms via multi-checkbox\n- DBs via multi-file interface\n- isobaric spec as --isobaric set1:tmt10plex:126 set2:6plex:sweep\n*/\n\n\nlet config = {\n  wfid: false,\n  wfversion: false,\n  analysisname: '',\n  flags: [],\n  multicheck: [],\n  isoquants: {},\n  fileparams: {},\n  inputparams: {},\n  multifileparams: {},\n  mzmldef: false,\n  v1: false,\n  v2: false,\n  version_dep: {\n    v1: {\n      instype: false,\n      dtype: false,\n    }\n  },\n}\nlet matchedFr = {};\n\nfunction validate() {\n  notif = {errors: {}, messages: {}, links: {}};\n  const charRe = RegExp('^[a-z0-9_-]+$', 'i');\n  if (!config.analysisname) {\n\t  notif.errors['Analysisname must be filled in'] = 1;\n\t} else if (!charRe.test(config.analysisname)) {\n\t\tnotif.errors['Analysisname may only contain a-z 0-9 _ -'] = 1;\n\t}\n\tif (!config.wfid) {\n\t\tnotif.errors['You must select a workflow'] = 1;\n\t}\n  if (!config.wfversion) {\n\t\tnotif.errors['You must select a workflow version'] = 1;\n\t}\n  if ('mzmldef' in wf.components && !config.mzmldef) {\n\t\tnotif.errors['You must select a mzml definition file'] = 1;\n  }\n  Object.values(dsets).forEach(ds => {\n    if (config.version_dep.v1.dtype.toLowerCase() !== 'labelcheck' && !ds.filesaresets && !ds.setname) {\n\t\t\tnotif.errors[`Dataset ${ds.proj} - ${ds.exp} - ${ds.run} needs to have a set name`] = 1;\n    } else if (ds.filesaresets) {\n      if (ds.files.filter(fn => !fn.setname).length) {\n\t\t\t  notif.errors[`File ${fn.name} needs to have a setname`] = 1;\n\t\t\t}\n    } else if (ds.setname && !charRe.test(ds.setname)) {\n\t\t\tnotif.errors[`Dataset ${ds.proj} - ${ds.exp} - ${ds.run} needs to have another set name: only a-z 0-9 _ are allowed`] = 1;\n\t\t}\n\t});\n  Object.entries(config.isoquants).forEach(([sname, isoq]) => {\n    Object.entries(isoq.samplegroups).forEach(([ch, sgroup]) => {\n      if (sgroup && !charRe.test(sgroup)) {\n        notif.errors[`Incorrect sample group name for set ${sname}, channel ${ch}, only A-Z a-z 0-9 _ are allowed`] =1; \n      }\n    })\n  })\n  return Object.keys(notif.errors).length === 0;\n}\n\n\nasync function storeAnalysis() {\n  if (!validate()) {\n  \treturn false;\n  }\n  runButtonActive = false;\n  postingAnalysis = true;\n  notif.messages['Validated data'] = 1;\n  let fns = Object.fromEntries(Object.entries(config.fileparams).filter(([k,v]) => v))\n  wf.fixedfileparams.forEach(fn => {\n    fns[fn.id] = fn.sfid\n  })\n  let multifns = Object.fromEntries(Object.entries(config.multifileparams).map(([k, v]) => [k, Object.values(v).filter(x => x)]).filter(([k, v]) => v.length));\n\n  notif.messages[`Using ${Object.keys(dsets).length} dataset(s)`] = 1;\n  notif.messages[`${Object.keys(fns).length} other inputfiles found`];\n  let post = {\n    analysis_id: analysis_id,\n    base_analysis: base_analysis,\n    dsids: Object.keys(dsets),\n    dssetnames: Object.fromEntries(Object.entries(dsets).filter(([x,ds]) => !ds.filesaresets).map(([dsid, ds]) => [dsid, ds.setname])),\n    fractions: Object.fromEntries(Object.values(dsets).flatMap(ds => ds.files.map(fn => [fn.id, fn.fr]))),\n    fnsetnames: Object.fromEntries(Object.entries(dsets).filter(([x,ds]) => ds.filesaresets).map(\n      ([dsid, ds]) => ds.files.map(fn => [fn.id, fn.setname])).flat()),\n    frregex: Object.fromEntries(Object.entries(dsets).map(([dsid, ds]) => [dsid, ds.frregex])),\n    singlefiles: fns,\n    multifiles: multifns,\n    components: {\n      mzmldef: config.mzmldef,\n      sampletable: false,\n    },\n    wfid: config.wfid,\n    nfwfvid: config.wfversion.id,\n    analysisname: `${allwfs[config.wfid].wftype}_${config.analysisname}`,\n    isoquant: {},\n    params: {\n      flags: Object.fromEntries(config.flags.map(x => [x, true])),\n      inputparams: config.inputparams,\n      multicheck: config.multicheck.reduce((acc, x) => {\n        const xspl = x.split('___');\n        acc[xspl[0]].push(xspl[1]);\n        return acc},\n        Object.fromEntries(config.multicheck.map(x => {\n          const xspl = x.split('___');\n          return [xspl[0], []]\n        }))),\n    },\n  };\n  if (config.v1) {\n    post.params.inst = ['--instrument', config.version_dep.v1.instype];\n  }\n  if ('isobaric_quant' in wf.components) {\n    post.isoquant = config.isoquants;\n  }\n\n  if ('isobaric_quant' in wf.components || 'sampletable' in wf.components) {\n    // sampletable [[ch, sname, groupname], [ch2, sname, samplename, groupname], ...]\n    // we can push sampletables on ANY workflow as nextflow will ignore non-params\n    const sampletable = Object.entries(config.isoquants).flatMap(([sname, isoq]) => \n      Object.entries(isoq.channels).map(([ch, sample]) => [ch, sname, sample[0], isoq.samplegroups[ch]]).sort((a, b) => {\n      return a[0].replace('N', 'A') > b[0].replace('N', 'A')\n      })\n    );\n    post.components.sampletable = sampletable.map(row => row.slice(0, 3).concat(row[3] ? row[3] : 'X__POOL'));\n  }\n   \n  // Post the payload\n  if (!Object.entries(notif.errors).filter(([k,v]) => v).length) {\n    notif.messages[`Storing analysis for ${config.analysisname}`] = 1;\n    const resp = await postJSON('/analysis/store/', post);\n    if (resp.error) {\n      notif.errors[resp.error] = 1;\n      if ('link' in resp) {\n        notif.links[resp.link] = 1;\n      }\n      if ('files_nods' in resp) {\n        // Dsets have been changed while editing analysis\n        const files_nodset = new Set(resp.files_nods);\n        Object.values(dsets).filter(ds => files_nodset.intersect(Object.values(ds.files).map(x => x.id))).forEach(ds => {\n          ds.changed = true;\n        });\n        Object.entries(dsets).filter(([dsid, ds]) => resp.ds_newfiles.indexOf(dsid) > -1).forEach(([dsid, ds]) => {\n          ds.changed = true;\n        });\n      }\n    } else {\n      analysis_id = resp.analysis_id;\n    }\n  }\n  postingAnalysis = false;\n  runButtonActive = true;\n}\n\n\nasync function runAnalysis() {\n  await storeAnalysis();\n  if (!Object.entries(notif.errors).filter(([k,v]) => v).length) {\n    notif.messages[`Queueing analysis job for ${config.analysisname}`] = 1;\n    const post = {\n      analysis_id: analysis_id,\n    }\n    const resp = await postJSON('/analysis/start/', post);\n    if (resp.error) {\n      notif.errors[resp.error] = 1;\n    } else {\n      window.location.href = '/?tab=searches';\n    }\n  }\n}\n\n\nasync function fetchWorkflow() {\n  let url = new URL('/analysis/workflow', document.location)\n  const params = {dsids: dsids.join(','), wfvid: config.wfversion.id};\n  url.search = new URLSearchParams(params).toString();\n  const result = await getJSON(url);\n  loadingItems = true;\n  if ('error' in result) {\n    const msg = `While fetching workflow versions, encountered: ${result.error}`;\n    notif.errors[msg] = 1;\n    setTimeout(function(msg) { notif.errors[msg] = 0 } , flashtime, msg);\n  } else {\n    libfiles = Object.fromEntries(Object.entries(result.wf.libfiles).map(([ft, lf]) => [ft, Object.fromEntries(lf.map(x => [x.id, x]))]));\n    libfnorder = Object.fromEntries(Object.entries(result.wf.libfiles).map(([ft, lf]) => [ft, lf.map(x => x.id)]));\n    prev_resultfiles = result.wf.prev_resultfiles;\n    wf = result.wf;\n    config.v1 = wf.analysisapi === 1;\n    config.v2 = wf.analysisapi === 2;\n  }\n  if (wf.multifileparams.length) {\n    config.multifileparams = Object.assign(config.multifileparams, Object.fromEntries(wf.multifileparams.filter(x => !(x.id in config.multifileparams)).map(x => [x.id, {0: ''}])));\n  }\n}\n\nasync function fetchAllWorkflows() {\n  let url = new URL('/analysis/workflows', document.location)\n  const result = await getJSON(url);\n  loadingItems = true;\n  if ('error' in result) {\n    const msg = `While fetching workflows, encountered: ${result.error}`;\n    notif.errors[msg] = 1;\n    setTimeout(function(msg) { notif.errors[msg] = 0 } , flashtime, msg);\n  } else {\n    allwfs = result.allwfs;\n    wforder = result.order;\n  }\n}\n\nasync function fetchDatasetDetails(fetchdsids) {\n  let url = new URL('/analysis/dsets/', document.location)\n  const params = {\n    dsids: fetchdsids ? fetchdsids.join(',') : dsids.join(','),\n    anid: existing_analysis ? existing_analysis.analysis_id : 0,\n  };\n  url.search = new URLSearchParams(params).toString();\n  const result = await getJSON(url);\n  if (result.error) {\n    const msg = result.errmsg;\n    notif.errors[msg] = 1;\n    setTimeout(function(msg) { notif.errors[msg] = 0 } , flashtime, msg);\n  } else {\n    Object.keys(result.dsets).forEach(x => {\n      dsets[x] = result.dsets[x];\n      dsets[x].changed = false;\n      });\n    Object.keys(dsets).forEach(x => {\n      dsets[x].changed = false;\n    })\n    Object.entries(dsets).filter(x=>x[1].prefrac).forEach(x=>matchFractions(dsets[x[0]]));\n    // API v1 stuff\n    const dtypes = new Set(Object.values(dsets).map(ds => ds.dtype.toLowerCase()));\n    config.version_dep.v1.dtype = dtypes.size > 1 ? 'mixed' : dtypes.keys().next().value;\n    const qtypes = new Set(Object.values(dsets).map(ds => ds.details.qtypeshort));\n    if (config.v1 && qtypes.size > 1) {\n      notif.errors['Mixed quant types detected, cannot use those in single run, use more advanced pipeline version'] = 1;\n    } else {\n      config.version_dep.v1.qtype = qtypes.keys().next().value;\n    }\n    const instypes = new Set(Object.values(dsets).flatMap(ds => ds.details.instrument_types).map(x => x.toLowerCase()));\n    if (config.v1 && instypes.size> 1) {\n      notif.errors['Mixed instrument types detected, cannot use those in single run, use more advanced pipeline version'] = 1;\n    } else {\n      config.version_dep.v1.instype = instypes.keys().next().value;\n    }\n  }\n}\n\n\nasync function loadAnalysisResults() {\n  if (added_analyses_order.indexOf(adding_analysis.selected) > -1) {\n    return;\n  }\n  let url = `/analysis/resultfiles/load/${adding_analysis.selected}/`;\n  const result = await getJSON(url);\n  if ('error' in result) {\n    const msg = `While fetching analysis, encountered: ${result.error}`;\n    notif.errors[msg] = 1;\n    setTimeout(function(msg) { notif.errors[msg] = 0 } , flashtime, msg);\n  } else {\n    added_analyses_order.push(adding_analysis.selected);\n    added_results[adding_analysis.selected] = result;\n  }\n}\n\n\nfunction removeAnalysisResults(anaid) {\n  if (added_analyses_order.indexOf(anaid) === -1) {\n    return\n  }\n  added_analyses_order = added_analyses_order.filter(x => x !== anaid);\n  delete(added_results[anaid]);\n  added_results = added_results;\n}\n\n\nasync function loadBaseAnalysis() {\n  let url = `/analysis/baseanalysis/load/${base_analysis.selected}/`;\n  const result = await getJSON(url);\n  if ('error' in result) {\n    const msg = `While fetching base analysis, encountered: ${result.error}`;\n    notif.errors[msg] = 1;\n    setTimeout(function(msg) { notif.errors[msg] = 0 } , flashtime, msg);\n  } else {\n    base_analysis.resultfiles = result.resultfiles;\n    let overlapping_setnames = new Set();\n    for (const dsid in result.datasets) {\n      if (dsid in dsets) {\n        dsets[dsid].setname = result.datasets[dsid].setname;\n        overlapping_setnames.add(dsets[dsid].setname);\n        dsets[dsid].regex = result.datasets[dsid].regex;\n      }\n    }\n    for (const sname in result.base_analysis.isoquants) {\n      if (overlapping_setnames.has(sname)) {\n        config.isoquants[sname] = result.base_analysis.isoquants[sname];\n      }\n    }\n    for (const key of ['mzmldef', 'flags', 'inputparams', 'multicheck', 'fileparams']) {\n      config[key] = result.base_analysis[key];\n    }\n    Object.assign(config.multifileparams, result.base_analysis.multifileparams);\n  }\n}\n\n\nfunction removeMultifile(fparam_id, key) {\n  delete(config.multifileparams[fparam_id][key]);\n  let newmfp = {}\n  Object.keys(config.multifileparams[fparam_id]).forEach((k, ix) => {\n    newmfp[ix] = config.multifileparams[fparam_id][k]\n  });\n  config.multifileparams[fparam_id] = newmfp;\n}\n\nfunction addMultifile(fparam_id) {\n  const keyints = Object.keys(config.multifileparams[fparam_id]).map(x => +x);\n  const newkey = keyints.length ? Math.max(...keyints) + 1 : 0;\n  config.multifileparams[fparam_id][newkey] = '';\n}\n\nfunction getIntextFileName(fnid, files) {\n  if (files && fnid in files) {\n    return files[fnid].name \n  } else {\n    return '';\n  }\n}\n\nfunction matchFractions(ds) {\n  let allfrs = new Set();\n  for (let fn of ds.files) {\n    const match = fn.name.match(RegExp(ds.frregex));\n    if (match) {\n      fn.fr = match[1];\n      allfrs.add(match[1]);\n    } else {\n      fn.fr = 'NA';\n    }\n  }\n\tmatchedFr[ds.id] = allfrs.size;\n}\n\nfunction sortChannels(channels) {\n  return Object.entries(channels).sort((a,b) => {\n\t  return a[0].replace('N', 'A') > b[0].replace('N', 'A')\n  }).map(x => {return {ch: x[0], sample: x[1][0], chid: x[1][1]}});\n}\n\nfunction updateIsoquant() {\n  // Add new set things if necessary\n  if ('isobaric_quant' in wf.components || 'sampletable' in wf.components) {\n    Object.values(dsets).forEach(ds => {\n      const errmsg = `Sample set mixing error! Channels for datasets with setname ${ds.setname} are not identical!`;\n      notif.errors[errmsg] = 0;\n      if (ds.setname && !(ds.setname in config.isoquants)) {\n        config.isoquants[ds.setname] = {\n          chemistry: ds.details.qtypeshort,\n          channels: ds.details.channels,\n          samplegroups: Object.fromEntries(Object.keys(ds.details.channels).map(x => [x, ''])),\n          denoms: Object.fromEntries(Object.keys(ds.details.channels).map(x => [x, false])),\n          report_intensity: false,\n          sweep: false,\n        };\n      } else if (ds.setname && ds.setname in config.isoquants) {\n        if (config.isoquants[ds.setname].channels !== ds.details.channels) {\n          notif.errors[errmsg] = 1;\n        }\n      }\n    });\n    // Remove old sets from config.isoquants if necessary\n    const dset_sets = new Set(Object.values(dsets).map(ds => ds.setname).filter(x => x));\n    Object.keys(config.isoquants).filter(x => !(dset_sets.has(x))).forEach(x => {\n      delete(config.isoquants[x])\n    });\n    config.isoquants = Object.assign({}, config.isoquants);  // assign so svelte notices (doesnt act on deletion)\n  }\n}\n\nasync function populate_analysis() {\n  config.wfid = existing_analysis.wfid;\n  config.wfversion_id = existing_analysis.wfversion_id;\n  config.wfversion = allwfs[existing_analysis.wfid].versions.filter(x => x.id === existing_analysis.wfversion_id)[0];\n  for (const key of ['analysisname', 'mzmldef', 'flags', 'inputparams', 'multicheck', 'fileparams', 'isoquants']) {\n    config[key] = existing_analysis[key];\n  }\n  await fetchWorkflow();\n  Object.assign(config.multifileparams, existing_analysis.multifileparams);\n  base_analysis = existing_analysis.base_analysis || base_analysis;\n  // FIXME now repopulate files with sample names if any\n}\n\n\nonMount(async() => {\n  await fetchAllWorkflows();\n  if (existing_analysis) {\n    await populate_analysis();\n  }\n  await fetchDatasetDetails(false);\n})\n</script>\n\n<style>\n.errormsg {\n  position: -webkit-sticky;\n  position: sticky;\n  top: 20px;\n  z-index: 50000;\n}\n</style>\n\n<div class=\"errormsg\">\n{#if Object.values(notif.errors).some(x => x === 1)}\n<div class=\"notification is-danger is-light\"> \n    {#each Object.entries(notif.errors).filter(x => x[1] == 1).map(x=>x[0]) as error}\n    <div>{error}</div>\n    {/each}\n</div>\n{/if}\n\n{#if Object.values(notif.links).some(x => x === 1)}\n<div class=\"notification is-danger is-light errormsg\"> \n    {#each Object.entries(notif.links).filter(x => x[1] == 1).map(x=>x[0]) as link}\n    <div>Click here: <a target=\"_blank\" href={link}>here</a></div>\n    {/each}\n</div>\n{/if}\n\n{#if Object.values(notif.messages).some(x => x === 1)}\n<div class=\"notification is-success is-light errormsg\"> \n    {#each Object.entries(notif.messages).filter(x => x[1] == 1).map(x=>x[0]) as message}\n    <div>{message}</div>\n    {/each}\n</div>\n{/if}\n</div>\n\n<div class=\"content\">\n\t<div class=\"title is-5\">Analysis </div>\n\t<div class=\"field is-horizontal\">\n    <div class=\"field-label is-normal\">\n      <label class=\"label\">Workflow:</label>\n    </div>\n    <div class=\"field-body\">\n      <div class=\"field\">\n        <div class=\"select\">\n          <select bind:value={config.wfid} on:change={e => wf = config.wfversion = false}>\n            <option disabled value={false}>Select workflow</option>\n            {#each wforder as wfid}\n            <option value={wfid}>{allwfs[wfid].name} </option>\n            {/each}\n          </select>\n        </div>\n      </div>\n    </div>\n    <div class=\"field-label is-normal\">\n      <label class=\"label\">Workflow version:</label>\n    </div>\n    <div class=\"field-body\">\n      <div class=\"field\">\n        <div class=\"select\" on:change={fetchWorkflow}>\n          <select bind:value={config.wfversion}>\n            <option disabled value={false}>Select workflow version</option>\n            {#if config.wfid}\n            {#each allwfs[config.wfid].versions as wfv}\n            <option value={wfv}>\n              {#if wfv.latest}\n              <span>LATEST: </span>\n              {/if}\n              {wfv.date} -- {wfv.name}\n            </option>\n            {/each}\n            {/if}\n          </select>\n        </div>\n      </div>\n    </div>\n\t</div>\n\n  {#if wf}\n\t<div class=\"field\">\n    <input type=\"text\" class=\"input\" bind:value={config.analysisname} placeholder=\"Please enter analysis name\">\n    <div>Full name will be <code>{allwfs[config.wfid].wftype}_{config.analysisname}</code>\n    This will be the folder name for the output and prefixed to the output filenames\n    </div>\n\t</div>\n\n  <div class=\"box\">\n    <div class=\"title is-5\">Fetch settings/files from a previous analysis</div>\n    {#if wf && 'complement_analysis' in wf.components}\n    <div class=\"checkbox\">\n      <input type=\"checkbox\" bind:checked={base_analysis.isComplement}>\n      <label class=\"checkbox\">\n        Complement previous analysis with new or re-run sets (with replaced or extra raw data)\n      </label>\n      <a title=\"Skips parts of analysis already run, faster output\"><i class=\"fa fa-question-circle\"></i></a>\n    </div>\n    {/if}\n    <DynamicSelect bind:intext={base_analysis.typedname} bind:selectval={base_analysis.selected} on:selectedvalue={e => loadBaseAnalysis()} niceName={x => x.name} fetchUrl=\"/analysis/baseanalysis/show/\" bind:fetchedData={base_analysis.fetched} />\n\t</div>\n\n  {#if 'mzmldef' in wf.components}\n  <div class=\"title is-5\">Mzml input type</div>\n  <div class=\"field\">\n    <div class=\"select\">\n      <select bind:value={config.mzmldef}>\n        <option>Please select one</option>\n        {#each Object.keys(wf.components.mzmldef) as comp}\n        <option value={comp}>{comp.split(' ').map(x => `${x[0].toUpperCase()}${x.slice(1).toLowerCase()}`).join(' ')} ({wf.components.mzmldef[comp].join(', ')})</option>\n        {/each}\n      </select>\n    </div>\n  </div>\n  {/if}\n  {/if}\n\n  <!-------------------------- ############### API v1? -->\n\t<div class=\"title is-5\">Datasets</div>\n  {#each Object.values(dsets) as ds}\n  <div class=\"box\">\n    {#if ds.dtype.toLowerCase() === 'labelcheck'}\n    <span class=\"has-text-primary\">{ds.proj} // Labelcheck // {ds.run} // {ds.details.qtype} // {ds.details.instruments.join(',')}</span>\n    {:else}\n\t\t<div class=\"columns\">\n\t\t  <div class=\"column\">\n        {#if !ds.prefrac}\n        <input type=\"checkbox\" bind:checked={ds.filesaresets}>\n\t\t\t\t<label class=\"checkbox\">Each file is a different sample</label>\n        {/if}\n        {#if !ds.filesaresets}\n\t\t\t  <div class=\"field\">\n          <input type=\"text\" class=\"input\" placeholder=\"Name of set\" bind:value={ds.setname} on:change={updateIsoquant}>\n\t\t\t  </div>\n        {/if}\n        <div class=\"subtitle is-6 has-text-primary\">\n          <span>{ds.proj} // {ds.exp} // {ds.run} //</span>\n          {#if !ds.prefrac}\n          <span>{ds.dtype}</span>\n          {:else if ds.hr}\n          <span>{ds.hr}</span>\n          {:else}\n          <span>{ds.prefrac}</span>\n          {/if}\n\t\t\t  </div>\n        {#if ds.changed}\n        <div class=\"has-text-danger\">\n          <span>This dataset has changed files while editing  <button on:click={e => fetchDatasetDetails([ds.id])} class=\"button is-small\">Reload dataset</button></span>\n        </div>\n        {/if}\n\t\t\t  <div class=\"subtitle is-6\">\n\t\t\t\t  <span>{ds.details.qtype} </span>\n          {#each Object.entries(ds.details.nrstoredfiles) as sf}\n\t\t      <span> // {sf[1]} {sf[0]} files </span>\n          {/each}\n\t\t\t\t  <span>// {ds.details.instruments.join(', ')} </span>\n\t\t\t  </div>\n        {#if ds.details.nrstoredfiles.refined_mzML}\n\t\t\t  <div class=\"subtitle is-6\"><strong>Enforcing use of refined mzML(s)</strong></div>\n        {/if}\n\t\t\t</div>\n\t\t\t<div class=\"column\">\n      {#if wf}\n        {#if ds.prefrac && 'mzmldef' in wf.components && config.mzmldef in wf.components.mzmldef && wf.components.mzmldef[config.mzmldef].indexOf('plate') > -1}\n        <div class=\"field\">\n\t\t\t\t\t<label class=\"label\">Regex for fraction detection</label>\n          <input type=\"text\" class=\"input\" on:change={e => matchFractions(ds)} bind:value={ds.frregex}>\n\t\t\t\t</div>\n\t\t\t\t<span>{matchedFr[ds.id]} fractions matched</span>\n        {/if}\n      {/if}\n\t\t\t</div>\n\t\t</div>\n    {#if ds.filesaresets}\n    {#each ds.files as fn}\n    <div class=\"columns\">\n\t\t  <div class=\"column\">{fn.name}</div>\n\t\t  <div class=\"column\">\n        <input type=\"text\" class=\"input\" bind:value={fn.setname} placeholder={fn.sample}>\n\t\t\t</div>\n\t\t</div>\n    {/each}\n    {/if}\n    {/if}\n  </div>\n  {/each}\n\n  {#if wf}\n  {#if 'isobaric_quant' in wf.components && Object.keys(config.isoquants).length}\n  <div class=\"box\">\n\t\t<div class=\"title is-5\">Isobaric quantification</div>\n    {#each Object.entries(config.isoquants) as isoq}\n    <div class=\"has-text-primary title is-6\">Set: {isoq[0]}</div>\n\n    {#if !('labelcheck' in wf.components)}\n    {#if Object.keys(config.isoquants).length === 1 && !Object.values(isoq[1].denoms).filter(x=>x).length}\n      <div class=\"field\">\n        <input type=\"checkbox\" bind:checked={isoq[1].sweep}>\n        <label class=\"checkbox\">Use median sweeping (no predefined denominators)\n          <span class=\"icon is-small\">\n            <a title=\"Pick median denominator per PSM, only for single-set analyses\"><i class=\"fa fa-question-circle\"></i></a>\n          </span>\n        </label>\n      </div>\n      {/if}\n\n      {#if !isoq[1].sweep && !Object.values(isoq[1].denoms).filter(x => x).length}\n      <div class=\"field\">\n        <input type=\"checkbox\" bind:checked={isoq[1].report_intensity}>\n        <label class=\"checkbox\">Report isobaric ion intensities instead of ratios\n          <span class=\"icon is-small\">\n            <a title=\"Reports median intensity rather than fold changes, not for use with DEqMS\"><i class=\"fa fa-question-circle\"></i></a>\n          </span>\n        </label>\n      </div>\n      {/if}\n    {/if}\n\n    <div class=\"columns\">\n      <div class=\"column is-three-quarters\">\n        <table class=\"table is-striped is-narrow\">\n          <thead>\n            <tr>\n            {#if !('labelcheck' in wf.components)}\n              {#if !isoq[1].sweep && !isoq[1].report_intensity}\n              <th>Denominator</th>\n              {:else}\n              <th><del>Denominator</del></th>\n              {/if}\n              <th>Channel</th>\n              <th>Sample name</th>\n              {/if}\n            {#if !('labelcheck' in wf.components)}\n              <th>Sample group \n                <span class=\"icon is-small\">\n                  <a title=\"For DEqMS and PCA plots\"><i class=\"fa fa-question-circle\"></i></a>\n                </span>\n                LEAVE EMPTY FOR INTERNAL STANDARDS!</th>\n              {/if}\n      \t\t  </tr>\n          </thead>\n          <tbody>\n            {#each sortChannels(isoq[1].channels) as {ch, sample}}\n            <tr>\n              {#if !('labelcheck' in wf.components)}\n              <td>\n                {#if !isoq[1].sweep && !isoq[1].report_intensity}\n                <input type=\"checkbox\" bind:checked={isoq[1].denoms[ch]} />\n                {/if}\n              </td>\n              {/if}\n              <td>{ch}</td>\n              <td>{sample}</td>\n              {#if !('labelcheck' in wf.components)}\n              <td>\n                <input type=\"text\" class=\"input\" bind:value={isoq[1].samplegroups[ch]} placeholder=\"Sample group or empty (e.g. CTRL, TREAT)\">\n              </td>\n              {/if}\n      \t\t  </tr>\n            {/each}\n          </tbody>\n        </table>\n      </div>\n    </div>\n    {/each}\n  </div>\n  {/if}\n\n  {#if wf.multicheck.length + wf.numparams.length + wf.flags.length}\n  <div class=\"box\">\n    <div class=\"title is-5\">Workflow parameters</div>\n    {#each wf.multicheck as {nf, id, name, opts}}\n    <div class=\"field\">\n      <label class=\"label\">{name} <code>{nf}</code></label> \n      {#each Object.entries(opts) as opt}\n      <div>\n        <input value={`${id}___${opt[0]}`} bind:group={config.multicheck} type=\"checkbox\">\n        <label class=\"checkbox\">{opt[1]}</label>\n      </div>\n      {/each}\n    </div>\n    {/each}\n\n    {#each wf.numparams as {nf, id, name, type}}\n    <div class=\"field\">\n      <label class=\"label\">{name} <code>{nf}</code></label> \n      <input type=\"number\" class=\"input\" bind:value={config.inputparams[id]}>\n    </div>\n    {/each}\n\n    <label class=\"label\">Config flags</label>\n    {#each wf.flags as {nf, id, name}}\n    <div>\n      <input value={id} bind:group={config.flags} type=\"checkbox\">\n      <label class=\"checkbox\">{name}</label>: <code>{nf}</code>\n    </div>\n    {/each}\n\t</div>\n  {/if}\n\n\n  {#if wf.multifileparams.length + wf.fileparams.length}\n  <div class=\"box\">\n    <div class=\"title is-5\">Input files</div>\n    Pick previous analyses to use results as input if needed:\n    <DynamicSelect bind:intext={adding_analysis.typedname} bind:selectval={adding_analysis.selected} on:selectedvalue={e => loadAnalysisResults()} niceName={x => x.name} fetchUrl=\"/analysis/baseanalysis/show/\" bind:fetchedData={adding_analysis.fetched} />\n\n    <div class=\"tags\">\n    {#each added_analyses_order as anaid}\n      <span class=\"tag is-medium is-info\">\n        {added_results[anaid].analysisname}\n        <button class=\"delete is-small\" on:click={e => removeAnalysisResults(anaid)}></button>\n      </span>\n    {/each}\n    </div>\n\n    {#each wf.multifileparams as filep}\n      <label class=\"label\">{filep.name}\n        <span class=\"icon is-small\">\n          <a on:click={e => addMultifile(filep.id)} title=\"Add another file\"><i class=\"fa fa-plus-square\"></i></a>\n        </span>\n      </label>\n      {#each Object.keys(config.multifileparams[filep.id]) as mfpkey}\n      <label class=\"label is-small\">\n        File nr. {mfpkey} \n        <span class=\"icon is-small\">\n          <a on:click={e => removeMultifile(filep.id, mfpkey)} title=\"Remove this file\"><i class=\"fa fa-trash-alt\"></i></a>\n        </span>\n      </label>\n        <div class=\"field\">\n          {#if !filep.allow_resultfile}\n          <DynamicSelect intext={getIntextFileName(config.multifileparams[filep.id][mfpkey], libfiles[filep.ftype])}\n          bind:selectval={config.multifileparams[filep.id][mfpkey]} niceName={x => x.name} fixedoptions={libfiles[filep.ftype]} fixedorder={libfnorder[filep.ftype]} />\n          {:else}\n          <DynamicSelect intext={getIntextFileName(config.multifileparams[filep.id][mfpkey], Object.assign(resultfiles, libfiles[filep.ftype]))} bind:selectval={config.multifileparams[filep.id][mfpkey]} niceName={x => x.name} fixedoptions={Object.assign(resultfiles, libfiles[filep.ftype])} fixedorder={resultfnorder.concat(libfnorder[filep.ftype])} />\n          {/if}\n        </div>\n      {/each}\n    {/each}\n\n    {#each wf.fileparams as filep}\n    <div class=\"field\">\n      <label class=\"label\">{filep.name}</label>\n      {#if !filep.allow_resultfile}\n      <DynamicSelect intext={getIntextFileName(config.fileparams[filep.id], libfiles[filep.ftype])} bind:selectval={config.fileparams[filep.id]} niceName={x => x.name} fixedoptions={libfiles[filep.ftype]} fixedorder={libfnorder[filep.ftype]} />\n      {:else}\n      <DynamicSelect intext={getIntextFileName(config.fileparams[filep.id], Object.assign(resultfiles, libfiles[filep.ftype]))} bind:selectval={config.fileparams[filep.id]} niceName={x => x.name} fixedoptions={Object.assign(resultfiles, libfiles[filep.ftype])} fixedorder={resultfnorder.concat(libfnorder[filep.ftype])} />\n      {/if}\n    </div>\n    {/each}\n\t</div>\n  {/if}\n\n\n  {#if wf.fixedfileparams.length}\n\t<div class=\"box\">\n    <div class=\"title is-5\">Predefined files</div>\n    {#each wf.fixedfileparams as ffilep}\n    <div class=\"field\">\n      <label class=\"label\">{ffilep.name}</label>\n      <div class=\"select\" >\n        <select>\n          <option disabled value=\"\">Fixed selection</option>\n          <option>{ffilep.fn} -- {ffilep.desc}</option>\n        </select>\n      </div>\n    </div>\n    {/each}\n  </div>\n  {/if}\n\n  {#if runButtonActive && (!existing_analysis || existing_analysis.editable)}\n  <a class=\"button is-primary\" on:click={storeAnalysis}>Store analysis</a>\n  <a class=\"button is-primary\" on:click={runAnalysis}>Store and queue analysis</a>\n  {:else if postingAnalysis}\n\t<a class=\"button is-primary is-loading\">Store analysis</a>\n\t<a class=\"button is-primary is-loading\">Store and queue analysis</a>\n  {:else}\n\t<a class=\"button is-primary\" disabled>Store analysis</a>\n\t<a class=\"button is-primary\" disabled>Store and queue analysis</a>\n  {/if}\n\n  {/if} \n</div>\n"
  ],
  "names": [],
  "mappings": "AA8dA,SAAS,cAAC,CAAC,AACT,QAAQ,CAAE,cAAc,CACxB,QAAQ,CAAE,MAAM,CAChB,GAAG,CAAE,IAAI,CACT,OAAO,CAAE,KAAK,AAChB,CAAC"
}