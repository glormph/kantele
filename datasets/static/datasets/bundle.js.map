{"version":3,"file":"bundle.js","sources":["../../../frontend/datasets/node_modules/svelte/internal/index.mjs","../../../frontend/datasets/src/funcJSON.js","../../../frontend/datasets/node_modules/svelte/store/index.mjs","../../../frontend/datasets/src/stores.js","../../../frontend/datasets/src/Param.svelte","../../../frontend/datasets/src/ErrorNotif.svelte","../../../frontend/datasets/src/Acquicomp.svelte","../../../frontend/datasets/src/DynamicSelect.svelte","../../../frontend/datasets/src/Prepcomp.svelte","../../../frontend/datasets/src/Msdata.svelte","../../../frontend/datasets/src/LCheck.svelte","../../../frontend/datasets/src/Files.svelte","../../../frontend/datasets/src/App.svelte","../../../frontend/datasets/src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction validate_store(store, name) {\n    if (!store || typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, callback) {\n    const unsub = store.subscribe(callback);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, fn) {\n    return definition[1]\n        ? assign({}, assign(ctx.$$scope.ctx, definition[1](fn ? fn(ctx) : {})))\n        : ctx.$$scope.ctx;\n}\nfunction get_slot_changes(definition, ctx, changed, fn) {\n    return definition[1]\n        ? assign({}, assign(ctx.$$scope.changed || {}, definition[1](fn ? fn(changed) : {})))\n        : ctx.$$scope.changed || {};\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value = ret) {\n    store.set(value);\n    return ret;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nlet running = false;\nfunction run_tasks() {\n    tasks.forEach(task => {\n        if (!task[0](now())) {\n            tasks.delete(task);\n            task[1]();\n        }\n    });\n    running = tasks.size > 0;\n    if (running)\n        raf(run_tasks);\n}\nfunction clear_loops() {\n    // for testing...\n    tasks.forEach(task => tasks.delete(task));\n    running = false;\n}\nfunction loop(fn) {\n    let task;\n    if (!running) {\n        running = true;\n        raf(run_tasks);\n    }\n    return {\n        promise: new Promise(fulfil => {\n            tasks.add(task = [fn, fulfil]);\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    // eslint-disable-next-line @typescript-eslint/no-object-literal-type-assertion\n    const target = {};\n    for (const k in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    for (const key in attributes) {\n        if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key in node) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group) {\n    const value = [];\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.push(group[i].__value);\n    }\n    return value;\n}\nfunction to_number(value) {\n    return value === '' ? undefined : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeName === name) {\n            for (let j = 0; j < node.attributes.length; j += 1) {\n                const attribute = node.attributes[j];\n                if (!attributes[attribute.name])\n                    node.removeAttribute(attribute.name);\n            }\n            return nodes.splice(i, 1)[0]; // TODO strip unwanted attributes\n        }\n    }\n    return svg ? svg_element(name) : element(name);\n}\nfunction claim_text(nodes, data) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 3) {\n            node.data = '' + data;\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return text(data);\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.data !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    if (value != null || input.value) {\n        input.value = value;\n    }\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\nfunction add_resize_listener(element, fn) {\n    if (getComputedStyle(element).position === 'static') {\n        element.style.position = 'relative';\n    }\n    const object = document.createElement('object');\n    object.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;');\n    object.type = 'text/html';\n    object.tabIndex = -1;\n    let win;\n    object.onload = () => {\n        win = object.contentDocument.defaultView;\n        win.addEventListener('resize', fn);\n    };\n    if (/Trident/.test(navigator.userAgent)) {\n        element.appendChild(object);\n        object.data = 'about:blank';\n    }\n    else {\n        object.data = 'about:blank';\n        element.appendChild(object);\n    }\n    return {\n        cancel: () => {\n            win && win.removeEventListener && win.removeEventListener('resize', fn);\n            element.removeChild(object);\n        }\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, false, false, detail);\n    return e;\n}\nclass HtmlTag {\n    constructor(html, anchor = null) {\n        this.e = element('div');\n        this.a = anchor;\n        this.u(html);\n    }\n    m(target, anchor = null) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(target, this.n[i], anchor);\n        }\n        this.t = target;\n    }\n    u(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    p(html) {\n        this.d();\n        this.u(html);\n        this.m(this.t, this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\n\nlet stylesheet;\nlet active = 0;\nlet current_rules = {};\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    if (!current_rules[name]) {\n        if (!stylesheet) {\n            const style = element('style');\n            document.head.appendChild(style);\n            stylesheet = style.sheet;\n        }\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    node.style.animation = (node.style.animation || '')\n        .split(', ')\n        .filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    )\n        .join(', ');\n    if (name && !--active)\n        clear_rules();\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        let i = stylesheet.cssRules.length;\n        while (i--)\n            stylesheet.deleteRule(i);\n        current_rules = {};\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error(`Function called outside component initialization`);\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = current_component;\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        callbacks.slice().forEach(fn => fn(event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nfunction flush() {\n    const seen_callbacks = new Set();\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        while (dirty_components.length) {\n            const component = dirty_components.shift();\n            set_current_component(component);\n            update(component.$$);\n        }\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                callback();\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n}\nfunction update($$) {\n    if ($$.fragment) {\n        $$.update($$.dirty);\n        run_all($$.before_update);\n        $$.fragment.p($$.dirty, $$.ctx);\n        $$.dirty = null;\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = program.b - t;\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = key && { [key]: value };\n        const child_ctx = assign(assign({}, info.ctx), info.resolved);\n        const block = type && (info.current = type)(child_ctx);\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            info.blocks[i] = null;\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            flush();\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = { [info.value]: promise };\n    }\n}\n\nconst globals = (typeof window !== 'undefined' ? window : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, changed, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(changed, child_ctx);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction measure(blocks) {\n    const rects = {};\n    let i = blocks.length;\n    while (i--)\n        rects[blocks[i].key] = blocks[i].node.getBoundingClientRect();\n    return rects;\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args) {\n    const attributes = Object.assign({}, ...args);\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === undefined)\n            return;\n        if (value === true)\n            str += \" \" + name;\n        const escaped = String(value)\n            .replace(/\"/g, '&#34;')\n            .replace(/'/g, '&#39;');\n        str += \" \" + name + \"=\" + JSON.stringify(escaped);\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, options = {}) => {\n            on_destroy = [];\n            const result = { head: '', css: new Set() };\n            const html = $$render(result, props, {}, options);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : ``;\n}\n\nfunction bind(component, name, callback) {\n    if (component.$$.props.indexOf(name) === -1)\n        return;\n    component.$$.bound[name] = callback;\n    callback(component.$$.ctx[name]);\n}\nfunction mount_component(component, target, anchor) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment.m(target, anchor);\n    // onMount happens before the initial afterUpdate\n    add_render_callback(() => {\n        const new_on_destroy = on_mount.map(run).filter(is_function);\n        if (on_destroy) {\n            on_destroy.push(...new_on_destroy);\n        }\n        else {\n            // Edge case - component was destroyed immediately,\n            // most likely as a result of a binding initialising\n            run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n    });\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    if (component.$$.fragment) {\n        run_all(component.$$.on_destroy);\n        component.$$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        component.$$.on_destroy = component.$$.fragment = null;\n        component.$$.ctx = {};\n    }\n}\nfunction make_dirty(component, key) {\n    if (!component.$$.dirty) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty = blank_object();\n    }\n    component.$$.dirty[key] = true;\n}\nfunction init(component, options, instance, create_fragment, not_equal, prop_names) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const props = options.props || {};\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props: prop_names,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : []),\n        // everything else\n        callbacks: blank_object(),\n        dirty: null\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, props, (key, ret, value = ret) => {\n            if ($$.ctx && not_equal($$.ctx[key], $$.ctx[key] = value)) {\n                if ($$.bound[key])\n                    $$.bound[key](value);\n                if (ready)\n                    make_dirty(component, key);\n            }\n            return ret;\n        })\n        : props;\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    $$.fragment = create_fragment($$.ctx);\n    if (options.target) {\n        if (options.hydrate) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment.l(children(options.target));\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor);\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement !== 'undefined') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set() {\n            // overridden by instance, if it has props\n        }\n    };\n}\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set() {\n        // overridden by instance, if it has props\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, detail));\n}\nfunction append_dev(target, node) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node });\n    append(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev(\"SvelteDOMRemove\", { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? [\"capture\"] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev(\"SvelteDOMAddEventListener\", { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev(\"SvelteDOMRemoveEventListener\", { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev(\"SvelteDOMRemoveAttribute\", { node, attribute });\n    else\n        dispatch_dev(\"SvelteDOMSetAttribute\", { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev(\"SvelteDOMSetProperty\", { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev(\"SvelteDOMSetDataset\", { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    dispatch_dev(\"SvelteDOMSetData\", { node: text, data });\n    text.data = data;\n}\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(`'target' is a required option`);\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn(`Component was already destroyed`); // eslint-disable-line no-console\n        };\n    }\n}\n\nexport { HtmlTag, SvelteComponent, SvelteComponentDev, SvelteElement, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, assign, attr, attr_dev, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_element, claim_space, claim_text, clear_loops, component_subscribe, createEventDispatcher, create_animation, create_bidirectional_transition, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, escape, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getContext, get_binding_group_value, get_current_component, get_slot_changes, get_slot_context, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, identity, init, insert, insert_dev, intros, invalid_attribute_name_character, is_client, is_function, is_promise, listen, listen_dev, loop, measure, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, update_keyed_each, validate_component, validate_store, xlink_attr };\n","async function parseResponse(response) {\n  let jsonresp;\n  try {\n    jsonresp = await response.json();\n  } catch(error) {\n    // Non-JSON responses, e.g. HTTP 500 server crash\n    return {ok: false, error: 'Server error encountered', status: response.status};\n  }\n  // Deliver HTTP errors if any\n  jsonresp.ok = response.ok;\n  return jsonresp;\n}\n\n\nexport async function getJSON(url) {\n  let response;\n  try {\n    response = await fetch(url);\n  } catch {\n      return {ok: false, error: 'Kantele encountered a network error', status: false}\n  }\n  return await parseResponse(response);\n}\n\n\nexport async function postJSON(url, postdata) {\n  let response;\n  try {\n    response = await fetch(url, {\n      method: 'POST', headers: {\n        'Content-Type': 'application/json'\n      }, body: JSON.stringify(postdata)\n    });\n  } catch {\n    return {ok: false, error: 'Kantele encountered a network error', status: false}\n  }\n  return await parseResponse(response);\n}\n","import { safe_not_equal, noop, run_all, is_function } from '../internal';\nexport { get_store_value as get } from '../internal';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe,\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = [];\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (let i = 0; i < subscribers.length; i += 1) {\n                    const s = subscribers[i];\n                    s[1]();\n                    subscriber_queue.push(s, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.push(subscriber);\n        if (subscribers.length === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            const index = subscribers.indexOf(subscriber);\n            if (index !== -1) {\n                subscribers.splice(index, 1);\n            }\n            if (subscribers.length === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n * @param {Stores} stores input stores\n * @param {function(Stores=, function(*)=):*}fn function callback that aggregates the values\n * @param {*=}initial_value when used asynchronously\n */\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => store.subscribe((value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","import { writable } from 'svelte/store';\n\nexport const dataset_id = writable(false);\n\nexport const datatype_id = writable('');\n\nexport const datasetFiles = writable({});\n\nexport const projsamples = writable({});\n\n","<script>\nimport { createEventDispatcher } from 'svelte';\nconst dispatch = createEventDispatcher();\n\nexport let param;\n\nfunction edited() { dispatch('edited');}\n\n</script>\n\n<div class=\"field\">\n  <label class=\"label\">{param.title}</label>\n  <div class=\"control\">\n    {#if param.inputtype === 'select'}\n    <div class=\"select\"> \n      <select bind:value={param.model} on:change={edited}>\n        <option disabled value=\"\">Please select one</option>\n        {#each param.fields as option}\n        <option value={option.value}>{option.text}</option>\n        {/each}\n      </select>\n    </div>\n    {:else if param.inputtype === 'text'}\n    <input type=\"text\" class=\"input\" placeholder={param.placeholder} bind:value={param.model} on:change={edited}>\n    {:else if param.inputtype === 'number'}\n    <input type=\"number\" class=\"input\" placeholder={param.placeholder} bind:value={param.model} on:change={edited}>\n    {:else if param.inputtype === 'checkbox'}\n    {#each param.fields as option}\n    <div class=\"control\">\n      <input bind:checked={option.checked} on:change={edited} type=\"checkbox\">{option.text}\n    </div>\n    {/each}\n    {/if}\n  </div>\n</div>\n","<script>\n\nexport let errors;\nexport let cssclass = '';\n</script>\n\n<style>\n  .sticky {\n    position: sticky;\n    position: -webkit-sticky;\n    top: 20px;\n    z-index: 1000;\n  }\n</style>\n\n{#if errors.length}\n<div class={`notification is-danger ${cssclass}`}>\n  <ul>\n    {#each errors as error}\n    <li>&bull; {error}</li>\n    {/each}\n  </ul>\n</div>\n{/if}\n","<script>\n\nimport { onMount } from 'svelte';\nimport { getJSON, postJSON } from './funcJSON.js'\nimport Param from './Param.svelte';\nimport ErrorNotif from './ErrorNotif.svelte';\nimport { dataset_id } from './stores.js';\n\nexport let errors;\n\nlet acquierrors = [];\n\n\nlet dsinfo = {\n  operator_id: '',\n  dynamic_rp: false,\n  rp_length: '',\n  params: [],\n}\n\nlet acqdata = {\n  operators: [],\n}\n\nlet edited = false;\n$: stored = $dataset_id && !edited;\n\nfunction editMade() { \n  errors = errors.length ? validate() : [];\n  edited = true;\n}\n\nexport function validate() {\n  let comperrors = [];\n\tif (!dsinfo.operator_id) {\n\t\tcomperrors.push('Operator is required');\n\t}\n\tif (!dsinfo.dynamic_rp && !dsinfo.rp_length) {\n\t\tcomperrors.push('Reverse phase is required');\n\t}\n\tfor (let key in dsinfo.params) {\n    if (!dsinfo.params[key].model) {\n\t\t\tcomperrors.push(dsinfo.params[key].title + ' is required');\n\t\t}\n\t}\n  return comperrors;\n}\n\nexport async function save() {\n  acquierrors = [];\n  errors = validate();\n  if (errors.length === 0) { \n    let postdata = {\n      dataset_id: $dataset_id,\n      operator_id: dsinfo.operator_id,\n      params: dsinfo.params,\n      rp_length: dsinfo.dynamic_rp ? '' : dsinfo.rp_length,\n    };\n    let url = '/datasets/save/acquisition/';\n    try {\n      const resp = await postJSON(url, postdata);\n      fetchData();\n    } catch(error) {\n      if (error.message === '404') { \n        acquierrors = [...acquierrors, 'Save dataset before saving acquisition'];\n      }\n    }\n  }\n}\n\n\nasync function fetchData() {\n  let url = '/datasets/show/acquisition/';\n  url = $dataset_id ? url + $dataset_id : url;\n\tconst response = await getJSON(url);\n  for (let [key, val] of Object.entries(response.acqdata)) { acqdata[key] = val; }\n  for (let [key, val] of Object.entries(response.dsinfo)) { dsinfo[key] = val; }\n  edited = false;\n}\n\nonMount(async() => {\n  fetchData();\n})\n\n</script>\n\n<style>\n</style>\n\n<h5 class=\"has-text-primary title is-5\">\n  {#if stored}\n  <i class=\"icon fas fa-check-circle\"></i>\n  {:else if edited}\n  <i class=\"icon fas fa-edit\"></i>\n  {/if}\n  Acquisition\n  <button class=\"button is-small is-danger has-text-weight-bold\" disabled={!edited} on:click={save}>Save</button>\n  <button class=\"button is-small is-info has-text-weight-bold\" disabled={!edited} on:click={fetchData}>Revert</button>\n</h5>\n\n<ErrorNotif errors={acquierrors} />\n\n<div class=\"field\">\n  <label class=\"label\">Operator</label>\n  <div class=\"control\">\n    <div class=\"select\">\n      <select on:change={editMade} bind:value={dsinfo.operator_id}>\n        <option disabled value=\"\">Please select one</option>\n        {#each acqdata.operators as operator}\n        <option value={operator.id}>{operator.name}</option>\n        {/each}\n      </select>\n    </div>\n  </div>\n</div>\n\n<div class=\"field\">\n  <label class=\"label\">Reverse phase length</label>\n  <div class=\"control\">\n    <input type=\"checkbox\" on:change={editMade} bind:checked={dsinfo.dynamic_rp}>Dynamic\n    {#if !dsinfo.dynamic_rp}\n    <input type=\"number\" on:change={editMade} class=\"input\" placeholder=\"in minutes\" bind:value={dsinfo.rp_length}>\n    {/if}\n  </div>\n</div>\n\n{#each Object.entries(dsinfo.params) as [param_id, param]}\n<Param bind:param={param} on:edited={editMade}/>\n{/each}\n","<script>\nimport { onMount } from 'svelte';\nimport { getJSON } from './funcJSON.js';\nimport { createEventDispatcher } from 'svelte';\n\nconst dispatch = createEventDispatcher();\n\nexport let selectval = '';\nexport let fixedoptions = {};\nexport let fixedorder = [];\nexport let options = Object.fromEntries(Object.entries(fixedoptions));\nexport let intext;\nexport let fetchUrl = false;\nexport let niceName = function(text) { return text; }\nexport let unknowninput = '__PLACEHOLDER__';\nexport let optorder = fixedorder.length ? fixedorder : Object.keys(options);\n\nlet selectedtext;\nlet placeholder = 'Filter by typing';\nlet typing = false;\n\n\nfunction inputdone() {\n  typing = false;\n  if (selectval && selectval in options) {\n    intext = niceName(options[selectval]);\n  } else if (unknowninput === '__PLACEHOLDER__') {\n    console.log('illegal value');\n    dispatch('illegalvalue');\n  } else {\n    console.log('new value');\n    unknowninput = intext;\n    dispatch('newvalue');\n  }\n}\n\nfunction deselect(ev) {\n  ev.target.selected = false;\n  intext = '';\n  placeholder = selectval ? niceName(selectval) : '';\n}\n\nfunction selectvalue(ev) {\n  selectval = options[ev.target.value].id;\n  unknowninput = '';\n  dispatch('selectedvalue'); \n}\n\nfunction hovervalue(ev) {\n  ev.target.selected = true;\n  const val = options[ev.target.value];\n  intext = niceName(val);\n}\n\nasync function fetchOptions() {\n  if (intext.length > 2 && fetchUrl) {\n    options = await getJSON(`${fetchUrl}?q=${intext}`);\n    optorder = Object.keys(options);\n  } else if (!fetchUrl && fixedoptions) {\n    options = Object.fromEntries(Object.entries(fixedoptions).filter(x => x[1].name.toLowerCase().indexOf(intext.toLowerCase()) > -1));\n    const keys = Object.keys(options);\n    optorder = fixedorder.length ? fixedorder.filter(x => keys.indexOf(x.toString()) > -1) : keys;\n  }\n}\n\nfunction starttyping() {\n  const keys = Object.keys(options);\n  optorder = fixedorder.length ? fixedorder : keys;\n  options = fixedorder.length ? fixedoptions : options;\n  typing = true;\n  placeholder = selectval ? niceName(selectval) : '';\n  selectval = '';\n  intext = '';\n}\n \n</script>\n\n<div class=\"control has-icons-right\">\n  <input type=\"text\" class=\"input is-narrow\" placeholder={placeholder} on:keyup={fetchOptions} on:focus={starttyping} on:blur={inputdone} bind:value={intext}>\n  <span class=\"icon is-right\"><i class=\"fas fa-chevron-down\"></i></span>\n\n  {#if typing}\n  <div class=\"select is-multiple\">\n    <select multiple>\n      {#if !Object.keys(options).length}\n      <option disabled>Type more or type less...</option>\n      {/if}\n      {#each optorder as optid} \n      <option value={optid} on:mousedown={e => selectvalue(e)} on:mouseout={e => deselect(e)} on:mouseover={e => hovervalue(e)}>{niceName(options[optid])}</option>\n      {/each}\n  </select>\n  </div>\n  {/if}\n</div>\n\n","<script>\nimport { onMount } from 'svelte';\nimport { getJSON, postJSON } from './funcJSON.js'\nimport Param from './Param.svelte';\nimport ErrorNotif from './ErrorNotif.svelte';\nimport DynamicSelect from './DynamicSelect.svelte';\nimport { dataset_id, datasetFiles, projsamples } from './stores.js';\n\nexport let errors;\n\nlet preperrors = [];\nlet edited = false;\n\n$: stored = $dataset_id && !edited;\n\n\nfunction editMade() { \n  errors = errors.length ? validate() : [];\n  edited = true; \n}\n\nlet prepdata = {\n  params: [],\n  enzymes: [],\n  no_enzyme: false,\n  quanttype: '',\n  quants: {},\n  labelfree_multisample: true,\n  labelfree_singlesample: {},\n  allspecies: [],\n  species: [],\n  samples: {},\n}\n\nlet selectedspecies;\nlet trysamplenames = '';\nlet labelfree_quant_id;\nlet foundNewSamples = false;\n\n\nfunction niceSpecies(species) { \n  let nice;\n  if (species.name) {\n    nice = `${species.name}, ${species.linnean}`;\n  } else {\n    nice = `${species.linnean}`;\n  }\n  return nice;\n}\n\nasync function fetchSpecies(intext) {\n  if (intext.length > 2) {\n    return await getJSON(`/datasets/show/species/?q=${intext}`);\n  }\n}\n\nfunction removeOrganism(org_id) {\n  prepdata.species = prepdata.species.filter(x => x.id !== org_id);\n  editMade();\n}\n\nfunction addOrganism() {\n  prepdata.species = [...prepdata.species, prepdata.allspecies[selectedspecies]];\n  editMade();\n}\n\n$: isLabelfree = prepdata.quanttype === labelfree_quant_id;\n\nfunction checkSamplesIfNewFiles() {\n  const assocs = Object.values($datasetFiles).map(x => x.associd);\n  prepdata.samples = Object.fromEntries(Object.entries(prepdata.samples).filter(x => assocs.indexOf(Number(x[0])) > -1));\n  for (let associd of assocs.filter(x => !(x in prepdata.samples))) {\n    prepdata.samples[associd] = {model: '', newprojsample: ''};\n  }\n}\n\n$: $datasetFiles ? checkSamplesIfNewFiles() : '';\n\nfunction checkIfNewSamples() {\n  /* checks if ANY sample in current quanttype is a newprojectsample, enabling save button */\n  if (prepdata.quanttype !== labelfree_quant_id) { // Cannot check isLabelfree here, that is slower to update than the call to this func\n    foundNewSamples = prepdata.quants[prepdata.quanttype].chans.some(ch => ch.newprojsample !== '');\n  } else if (!prepdata.labelfree_multisample) {\n    foundNewSamples = prepdata.labelfree_singlesample.newprojsample !== '';\n  } else {\n    foundNewSamples = Object.values(prepdata.samples).some(x => x.newprojsample !== '')\n  }\n}\n\nfunction checkNewSampleLabelfree(associd=false) {\n  /* Checks if entered sample is found in project or if it is a new sample */\n  let sample;\n  if (!prepdata.labelfree_multisample) {\n    sample = prepdata.labelfree_singlesample.newprojsample\n  } else {\n    sample = prepdata.samples[associd].newprojsample;\n  }\n  if (sample == '') { \n    return \n  } else {\n    let uppername = sample.trim().toUpperCase();\n    let found = Object.entries(projsamples).filter(x=>x[1].name.toUpperCase() == uppername).map(x=>x[0])[0]\n    if (found && !prepdata.labelfree_multisample) {\n      prepdata.labelfree_singlesample.model = found;\n      prepdata.labelfree_singlesample.newprojsample = '';\n    } else if (found) {\n      prepdata.samples[associd].model = found;\n      prepdata.samples[associd].newprojsample = '';\n      /* new samples filled in will reset the dropdown ones, do not do this, only on save */\n//    }  else if (prepdata.labelfree_multisample) {\n//      prepdata.samples[associd].model = '';\n//    } else {\n//      prepdata.labelfree_singlesample.model = '';\n    }\n    checkIfNewSamples();\n  }\n}\n\nfunction checkNewSampleIso(chanix) {\n  /* Checks if entered sample is found in project or if it is a new sample */\n  if (prepdata.quants[prepdata.quanttype].chans[chanix].newprojsample == '') { \n    /* at fetchdata, samples are assigned, on:change fires and this is called */\n    return \n  } else {\n    let uppername = prepdata.quants[prepdata.quanttype].chans[chanix].newprojsample.trim().toUpperCase();\n    let found = Object.entries(projsamples).filter(x=>x[1].name.toUpperCase() == uppername).map(x=>x[0])[0]\n    if (found) {\n      prepdata.quants[prepdata.quanttype].chans[chanix].model = found;\n      prepdata.quants[prepdata.quanttype].chans[chanix].newprojsample = '';\n    }\n    checkIfNewSamples();\n  }\n}\n\nfunction parseSampleNames() {\n  /* Parses samples/files/channel combinations pasted in textbox */\n  let ixmap = {};\n  let fnmap = {};\n  if (isLabelfree && !prepdata.labelfree_multisample) {\n    return 0;\n  } else if (isLabelfree) {\n    for (let fn of Object.values($datasetFiles)) {\n      fnmap[fn.name] = fn;\n    }\n  } else {\n    prepdata.quants[prepdata.quanttype].chans.forEach(function(ch, ix) {\n      ixmap[ch.name] = ix;\n    });\n    }\n  for (let line of trysamplenames.trim().split('\\n')) {\n    if (line.indexOf('\\t') > -1) {\n      line = line.trim().split('\\t').map(x => x.trim());\n    } else if (line.indexOf('    ') > -1) {\n      line = line.trim().split('    ').map(x => x.trim());\n    }\n    let nps, ix, aid;\n    if (isLabelfree) {\n      line[0] in fnmap ? (aid = fnmap[line[0]], nps = line[1]) : false;\n      line[1] in fnmap ? (aid = fnmap[line[1]], nps = line[0]) : false;\n      if (aid) {\n        prepdata.samples[aid.associd].newprojsample = nps;\n        checkNewSampleLabelfree(aid.associd);\n      }\n    } else {\n      line[0] in ixmap ? (ix = ixmap[line[0]], nps = line[1]) : false;\n      line[1] in ixmap ? (ix = ixmap[line[1]], nps = line[0]) : false;\n      if (ix > -1) {\n        prepdata.quants[prepdata.quanttype].chans[ix].newprojsample = nps;\n        checkNewSampleIso(ix);\n      }\n    }\n  }\n  editMade();\n}\n\nfunction resetNewSampleName(chan_or_sample) {\n  chan_or_sample.newprojsample = '';\n  checkIfNewSamples();\n  editMade();\n}\n\nasync function doSampleSave(ch_or_samfn, ix) { \n  /* Saves a new sample name to the project on backend */\n  let postdata = {\n    dataset_id: $dataset_id, \n    samplename: ch_or_samfn.newprojsample\n  };\n  let url = '/datasets/save/projsample/';\n  let response;\n  try {\n    response = await postJSON(url, postdata);\n  } catch(error) {\n    if (error.message === '404') {\n      preperrors = [preperrors, 'Save dataset before saving new samples'];\n    }\n    return;\n  }\n  // just add the latest projsample, do not just assign the whole projsamples dict, async problems!\n  projsamples[response.psid] = {name: response.psname, id: response.psid};\n  return [response.psid, ix];\n}\n\nasync function saveNewSamples() {\n  /* Goes through each of the new sample names and */\n  let saves = [];\n  if (!isLabelfree) {\n    prepdata.quants[prepdata.quanttype].chans.map(function(ch, ix) { return [ix, ch]}).filter(ch => ch[1].newprojsample).forEach(function(ch) {\n      saves.push(doSampleSave(ch[1], ch[0]));\n    }); \n    for (let item of saves) {\n      let [psid, ix] = await item;\n      prepdata.quants[prepdata.quanttype].chans[ix].newprojsample = '';\n      prepdata.quants[prepdata.quanttype].chans[ix].model = psid;\n    }\n  } else if (!prepdata.labelfree_multisample && foundNewSamples) {\n    const savedsample = await doSampleSave(prepdata.labelfree_singlesample);\n    prepdata.labelfree_singlesample.model = savedsample[0];\n    prepdata.labelfree_singlesample.newprojsample = '';\n  } else {\n    Object.entries(prepdata.samples).filter(x => x[1].newprojsample).forEach(function(samfn) {\n      saves.push(doSampleSave(samfn[1], samfn[0]));\n    });\n    for (let item of saves) {\n      let [psid, associd] = await item;\n      prepdata.samples[associd].newprojsample = '';\n      prepdata.samples[associd].model = psid;\n    }\n  }\n  checkIfNewSamples();\n}\n\nexport function validate() {\n  let comperrors = [];\n\tif (!prepdata.no_enzyme && !prepdata.enzymes.filter.length) {\n\t\tcomperrors.push('Enzyme selection is required');\n\t}\n\tif (!prepdata.quanttype) {\n\t\tcomperrors.push('Quant type selection is required');\n\t}\n  if (isLabelfree && prepdata.labelfree_multisample) {\n\t\tfor (let fn of Object.values($datasetFiles)) {\n\t\t\tif (!prepdata.samples[fn.associd].model && !prepdata.samples[fn.associd].newprojsample) {\n\t\t\t\tcomperrors.push('Labelfree requires sample name for each file');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\t\n  } else if (isLabelfree) {\n    if (prepdata.labelfree_singlesample.model === '') {\n      comperrors.push('Labelfree singlesample requires a sample name');\n    }\n\t} else if (prepdata.quanttype in prepdata.quants) {\n\t\tfor (let ch of prepdata.quants[prepdata.quanttype].chans) {\n\t\t\tif (ch.model === '') { \n\t\t\t\tcomperrors.push('Sample name for each channel is required');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n  for (let param of Object.values(prepdata.params).filter(p => p.inputtype !== 'checkbox')) {\n    if (!param.model) {\n\t\t\tcomperrors.push(param.title + ' is required');\n\t\t}\n\t}\n  for (let param of Object.values(prepdata.params).filter(p => p.inputtype === 'checkbox')) {\n    if (!param.fields.some(f => f.checked)) {\n\t\t\tcomperrors.push(param.title + ' is required');\n\t\t}\n\t}\n\tif (!Object.keys(prepdata.species).length) {\n\t\tcomperrors.push('Organism(s) is/are required');\n\t}\n  return comperrors;\n}\n\nexport async function save() {\n  errors = validate();\n  if (!Object.keys($datasetFiles).length && isLabelfree) {\n    preperrors = [...preperrors, 'Add files before saving data'];\n  }\n  if (!$dataset_id) {\n    preperrors = [...preperrors, 'Save dataset before saving sample prep'];\n  }\n  if (errors.length === 0 && preperrors.length === 0) { \n    let postdata = {\n      dataset_id: $dataset_id,\n      enzymes: prepdata.no_enzyme ? [] : prepdata.enzymes,\n      params: prepdata.params,\n      quanttype: prepdata.quanttype,\n      labelfree: isLabelfree,\n      species: prepdata.species,\n    };\n    if (!isLabelfree) {\n      postdata.samples = prepdata.quants[prepdata.quanttype].chans;\n    } else if (prepdata.labelfree_multisample) {\n      postdata.filenames = Object.values($datasetFiles);\n      postdata.samples = prepdata.samples;\n    } else {\n      postdata.filenames = Object.values($datasetFiles);\n      postdata.samples = Object.fromEntries(postdata.filenames.map(fn => [fn.associd, prepdata.labelfree_singlesample]));\n    }\n    let url = '/datasets/save/sampleprep/';\n    await postJSON(url, postdata);\n    fetchData();\n  }\n}\n\nasync function fetchData() {\n  let url = '/datasets/show/sampleprep/';\n  url = $dataset_id ? url + $dataset_id : url;\n\tconst response = await getJSON(url);\n  for (let [key, val] of Object.entries(response)) { prepdata[key] = val; }\n  labelfree_quant_id = Object.entries(prepdata.quants).filter(x => x[1].name === 'labelfree').map(x=>Number(x[0])).pop();\n  edited = false;\n}\n\nonMount(async() => {\n  await fetchData();\n})\n\n</script>\n\n\n<h5 id=\"sampleprep\" class=\"has-text-primary title is-5\">\n  {#if stored}\n  <i class=\"icon fas fa-check-circle\"></i>\n  {:else if edited}\n  <i class=\"icon fas fa-edit\"></i>\n  {/if}\n  Sample prep\n  <button class=\"button is-small is-danger has-text-weight-bold\" disabled={!edited} on:click={save}>Save</button>\n  <button class=\"button is-small is-info has-text-weight-bold\" disabled={!edited} on:click={fetchData}>Revert</button>\n</h5>\n\n<ErrorNotif errors={preperrors} />\n\n<div class=\"field\">\n  <label class=\"label\">Organism</label>\n  <DynamicSelect intext=\"Type to get more organisms\" bind:options={prepdata.allspecies} optorder={Object.keys(prepdata.allspecies)} bind:selectval={selectedspecies} fetchUrl=\"/datasets/show/species/\" niceName={niceSpecies} on:selectedvalue={addOrganism} />\n</div>\n<div class=\"tags\">\n  {#each prepdata.species as spec}\n  <span class=\"tag is-medium is-info\">\n    {niceSpecies(spec)}\n    <button class=\"delete is-small\" on:click={e => removeOrganism(spec.id)}></button>\n  </span>\n{/each}\n</div>\n\n<div class=\"field\">\n  <label class=\"label\">Enzymes</label>\n  <input type=\"checkbox\" on:change={editMade} bind:checked={prepdata.no_enzyme}>No enzyme\n  {#if !prepdata.no_enzyme}\n  {#each prepdata.enzymes as enzyme}\n  <div class=\"control\">\n    <input on:change={editMade} bind:checked={enzyme.checked} type=\"checkbox\">{enzyme.name}\n  </div>\n  {/each}\n  {/if}\n</div>\n\n{#each Object.entries(prepdata.params) as [param_id, param]}\n<Param bind:param={param} on:edited={editMade} />\n{/each}\n\n\n<div class=\"field\">\n  <label class=\"label\">Quant type</label>\n  <div class=\"control\">\n    <div class=\"select\">\n      <select on:change={checkIfNewSamples} bind:value={prepdata.quanttype}>\n        <option disabled value=\"\">Please select one</option>\n        {#each Object.values(prepdata.quants) as quant}\n        <option value={quant.id}>{quant.name}</option>\n        {/each}\n      </select>\n    </div>\n  </div>\n</div>\n\n{#if prepdata.quanttype}\n<div class=\"field\">\n  <label class=\"label\">Samples</label>\n  <textarea class=\"textarea\" bind:value={trysamplenames} placeholder=\"Try this: paste your sample names here (one line per sample, tab separated sample/file or channel)\"></textarea>\n  <a class=\"button is-primary\" on:click={parseSampleNames}>Parse sample names</a>\n  <div class=\"control\">\n    {#if isLabelfree}\n    <div id=\"labelfree_samples\">\n      <input type=\"checkbox\" on:change={checkIfNewSamples} bind:checked={prepdata.labelfree_multisample}>One sample per file?\n    </div>\n    {/if}\n  </div>\n</div>\n<table class=\"table is-fullwidth\" >\n  <thead>\n    <tr>\n      {#if isLabelfree && prepdata.labelfree_multisample}\n      <th>Filename</th>\n      {:else if !isLabelfree}\n      <th>Channel</th>\n      {/if} \n      <th colspan=\"2\">Sample name \n        {#if foundNewSamples}\n        <a class=\"button is-danger is-small is-pulled-right\" on:click={saveNewSamples}>Save new samples</a>\n        {:else}\n        <a class=\"button is-danger is-small is-pulled-right\" disabled>Save new samples</a>\n        {/if}\n      </th>\n    </tr>\n  </thead>\n  <tbody>\n    {#if !isLabelfree}\n    {#each prepdata.quants[prepdata.quanttype].chans as channel, chix}\n    <tr>\n      <td>{channel.name}</td>\n      <td>\n        <div class=\"select\">\n          <select bind:value={channel.model} on:change={e => resetNewSampleName(channel)}>\n            <option disabled value=\"\">Pick a project-sample</option>\n            {#each Object.entries(projsamples) as [s_id, sample]}\n            <option value={s_id}>{sample.name}</option>\n            {/each}\n          </select>\n        </div>\n      </td>\n      <td>\n        <p class={channel.newprojsample && foundNewSamples ? 'control has-icons-left' : 'control'}>\n        <input bind:value={channel.newprojsample} class=\"input is-normal\" on:change={e => checkNewSampleIso(chix)} placeholder=\"or define a new sample\">\n        {#if foundNewSamples && channel.newprojsample}\n        <span class=\"icon is-left has-text-danger\">\n          <i class=\"fas fa-asterisk\"></i>\n        </span>\n        {/if}\n        </p>\n      </td>\n    </tr>\n    {/each}\n    {:else if isLabelfree && prepdata.labelfree_multisample}\n    {#each Object.values($datasetFiles) as file}\n    {#if file.associd in prepdata.samples }\n    <tr>\n      <td>{file.name}</td>\n      <td>\n        <div class=\"select\">\n          <select bind:value={prepdata.samples[file.associd].model} on:change={e => resetNewSampleName(prepdata.samples[file.associd])}> \n            <option disabled value=\"\">Pick a project-sample</option>\n            {#each Object.entries(projsamples) as [s_id, sample]}\n            <option value={s_id}>{sample.name}</option>\n            {/each}\n          </select>\n        </div>\n      </td>\n      <td><input bind:value={prepdata.samples[file.associd].newprojsample} on:change={e => checkNewSampleLabelfree(file.associd)} placeholder=\"or define a new sample\" class=\"input is-normal\"></td> \n    </tr>\n    {/if}\n    {/each}\n    {:else if isLabelfree && Object.keys($datasetFiles).length}\n    <tr><td>\n        <div class=\"select\">\n          <select bind:value={prepdata.labelfree_singlesample.model} on:change={e => resetNewSampleName(prepdata.labelfree_singlesample)}>\n            <option disabled value=\"\">Pick a project-sample</option>\n            {#each Object.entries(projsamples) as [s_id, sample]}\n            <option value={s_id}>{sample.name}</option>\n            {/each}\n          </select>\n        </div>\n      </td>\n      <td><input bind:value={prepdata.labelfree_singlesample.newprojsample} on:change={e => checkNewSampleLabelfree(prepdata.labelfree_singlesample)} placeholder=\"or define a new sample\" class=\"input is-normal\"></td>\n    </tr>\n\n    {/if}\n  </tbody>\n</table>\n{/if}\n","<script>\n\nimport { createEventDispatcher } from 'svelte';\nconst dispatch = createEventDispatcher();\n\n// props\nexport let dsinfo;\nexport let experiments;\nexport let hirief_ranges;\nexport let prefracs;\nexport let isNewExperiment;\n\nlet errors = [];\n\nfunction toggle_experiment() {\n  isNewExperiment = isNewExperiment === false;\n}\n\n$: hiriefselected = prefracs.some(pf => pf.id == dsinfo.prefrac_id && pf.name.toLowerCase().indexOf('hirief') > -1)\n\nfunction editMade() {\n  dispatch('edited');\n}\n\nexport function validate() {\n  errors = [];\n\tif (hiriefselected && !dsinfo.hiriefrange) {\n\t\terrors.push('HiRIEF range is required');\n\t}\n\telse if (!hiriefselected && dsinfo.prefrac_id && !dsinfo.prefrac_length) {\n\t\terrors.push('Prefractionation length is required');\n\t}\n\tif (dsinfo.prefrac_id && !dsinfo.prefrac_amount) {\n\t\terrors.push('Prefractionation fraction amount is required');\n\t}\n  return errors;\n}\n\nfunction save() {\n  if (!validate) { return }\n\n}\n\n</script>\n\n<div class=\"field\">\n  <label class=\"label\">Experiment name\n    <a class=\"button is-danger is-outlined is-small\" on:click={toggle_experiment}>\n    {#if isNewExperiment}\n    Existing experiment\n    {:else}\n    Create new experiment\n    {/if}\n    </a>\n  </label>\n  <div class=\"control\">\n    {#if isNewExperiment}\n    <input class=\"input\" bind:value={dsinfo.newexperimentname} on:change={editMade} type=\"text\" placeholder=\"Experiment name\">\n    {:else}\n    <div class=\"select\">\n      <select bind:value={dsinfo.experiment_id} on:change={editMade}>\n        <option disabled value=\"\">Please select one</option>\n        {#each experiments as exp}\n        <option value={exp.id}>{exp.name}</option>\n        {/each}\n      </select>\n    </div>\n    {/if}\n  </div>\n</div>\n\n<div class=\"field\">\n  <label class=\"label\">Prefractionation</label>\n  <div class=\"control\">\n    <div class=\"select\">\n      <select on:change={editMade} bind:value={dsinfo.prefrac_id}>\n        <option value=\"\">None</option>\n        {#each prefracs as prefrac}\n        <option value={prefrac.id}>{prefrac.name}</option>\n        {/each}\n      </select>\n    </div>\n  </div>\n</div>\n\n{#if hiriefselected}\n<div class=\"field\"> \n  <label class=\"label\">HiRIEF range</label>\n  <div class=\"control\">\n    <div class=\"select\">\n      <select on:change={editMade} bind:value={dsinfo.hiriefrange}>\n        <option disabled value=\"\">Please select one</option>\n        {#each hirief_ranges as range}\n        <option value={range.id}>{range.name}</option>\n        {/each}\n      </select>\n    </div>\n  </div>\n</div>\n{:else if dsinfo.prefrac_id}\n<div class=\"field\">\n  <label class=\"label\">Prefractionation length</label>\n  <div class=\"control\">\n    <input type=\"number\" class=\"input\" placeholder=\"in minutes\" on:change={editMade} bind:value={dsinfo.prefrac_length}>\n  </div>\n</div>\n{/if}\n{#if dsinfo.prefrac_id}\n<div class=\"field\">\n  <label class=\"label\">Number of fractions</label>\n  <div class=\"control\">\n    <input type=\"number\" class=\"input\" placeholder=\"How many fractions of prefractionation\" on:change={editMade} bind:value={dsinfo.prefrac_amount}>\n  </div>\n</div>\n{/if}\n","<script>\nimport { onMount } from 'svelte';\nimport { getJSON, postJSON } from './funcJSON.js'\nimport { dataset_id, datasetFiles, projsamples } from './stores.js';\nimport ErrorNotif from './ErrorNotif.svelte';\nimport DynamicSelect from './DynamicSelect.svelte';\n\nexport let errors;\n\nlet lcerrors = [];\nlet channelError = {};\n\nlet lcdata = {\n  quants: {},\n  quanttype: '',\n  samples: {},\n}\nlet edited = false;\n\n$: Object.keys($datasetFiles).length ? fetchData() : false;\n\n$: foundNewSamples = Object.values(lcdata.samples).some(x => x.newprojsample !== '');\n$: stored = $dataset_id && !edited;\n\n\nfunction editMade() {\n  edited = true;\n}\n\nfunction okChannel(fid) {\n  lcdata.samples[fid].badChannel = false;\n  editMade();\n}\n\nfunction badChannel(fid) {\n  console.log('bad ch');\n  console.log(fid);\n  lcdata.samples[fid].badChannel = true;\n}\n\n\nasync function doSampleSave(ch_or_samfn, ix) { \n  /* Saves a new sample name to the project on backend */\n  let postdata = {\n    dataset_id: $dataset_id, \n    samplename: ch_or_samfn.newprojsample\n  };\n  let url = '/datasets/save/projsample/';\n  const response = await postJSON(url, postdata);\n  // just add the latest projsample, do not just assign the whole projsamples dict, async problems!\n  projsamples[response.psid] = response.psname;\n  return [response.psid, ix];\n}\n\nasync function saveNewSamples() {\n  /* Goes through each of the new sample names and */\n  let saves = [];\n  Object.entries(lcdata.samples).filter(x => x[1].newprojsample).forEach(function(samfn) {\n    saves.push(doSampleSave(samfn[1], samfn[0]));\n  });\n  for (let item of saves) {\n    let [psid, associd] = await item;\n    lcdata.samples[associd].newprojsample = '';\n    lcdata.samples[associd].sample = psid;\n  }\n}\n\nfunction checkNewSample(file) {\n  /* Checks if entered sample is found in project or if it is a new sample */\n  let uppername = lcdata.samples[file.associd].newprojsample.trim().toUpperCase();\n  let found = Object.entries(projsamples).filter(x=>x[1].name.toUpperCase() == uppername).map(x=>x[0])[0]\n  if (found) {\n    lcdata.samples[file.associd].sample = parseInt(found);\n    lcdata.samples[file.associd].newprojsample = '';\n  }\n  editMade();\n}\n\nfunction validate() {\n  let comperrors = [];\n\tif (!lcdata.quanttype) {\n\t\tcomperrors.push('Quant type selection is required');\n\t}\n  for (let fn of Object.values($datasetFiles)) {\n    if (!lcdata.samples[fn.associd].sample) {\n      comperrors.push('Sample name for each file/channel is required');\n    }\n    if (!lcdata.samples[fn.associd].channel) {\n      comperrors.push('Channel for each file/sample is required');\n    }\n  }\t\n  return comperrors;\n}\n\nasync function save() {\n  errors = validate();\n  if (!Object.keys($datasetFiles).length) {\n    lcerrors = [...lcerrors, 'Add files before saving data'];\n  }\n  if (errors.length === 0) { \n    let postdata = {\n      dataset_id: $dataset_id,\n      quanttype: lcdata.quanttype,\n      samples: lcdata.samples,\n      filenames: Object.values($datasetFiles),\n    }\n    console.log(postdata);\n    const url = '/datasets/save/labelcheck/';\n    const response = await postJSON(url, postdata);\n    fetchData();\n  }\n}\n\nasync function fetchData() {\n  let url = '/datasets/show/labelcheck/';\n  url = $dataset_id ? url + $dataset_id : url;\n\tconst response = await getJSON(url);\n  for (let [key, val] of Object.entries(response)) { lcdata[key] = val; }\n  edited = false;\n}\n\nonMount(async() => {\n  await fetchData();\n})\n</script>\n\n\n<h5 id=\"labelcheck\" class=\"has-text-primary title is-5\">\n  {#if stored}\n  <i class=\"icon fas fa-check-circle\"></i>\n  {:else if edited}\n  <i class=\"icon fas fa-edit\"></i>\n  {/if}\n  Label check\n  <button class=\"button is-small is-danger has-text-weight-bold\" disabled={!edited} on:click={save}>Save</button>\n  <button class=\"button is-small is-info has-text-weight-bold\" disabled={!edited} on:click={fetchData}>Revert</button>\n</h5>\n\n<ErrorNotif errors={lcerrors} />\n\n<div class=\"field\">\n  <label class=\"label\">Quant type</label>\n  <div class=\"control\">\n    <div class=\"select\">\n      <select on:change={editMade} bind:value={lcdata.quanttype}>\n        <option disabled value=\"\">Please select one</option>\n        {#each Object.values(lcdata.quants) as quant}\n        <option value={quant.id}>{quant.name}</option>\n        {/each}\n      </select>\n    </div>\n  </div>\n</div>\n\n{#if foundNewSamples}\n<a class=\"button is-danger is-small is-pulled-right\" on:click={saveNewSamples}>Save new samples</a>\n{:else}\n<a class=\"button is-danger is-small is-pulled-right\" disabled>Save new samples</a>\n{/if}\n\n<table class=\"table is-fullwidth\" >\n  <thead>\n    <tr>\n      <th>Sample</th>\n      <th>Channel</th>\n    </tr>\n  </thead>\n  {#if Object.keys(lcdata.samples).length}\n  <tbody>\n    {#each Object.values($datasetFiles) as file}\n    {#if file.associd in lcdata.samples}\n    <tr>\n      <td>\n        <label class=\"label\">\n          {#if lcdata.samples[file.associd].newprojsample}\n          <span class=\"icon has-text-danger\"><i class=\"fas fa-asterisk\"></i></span>\n          {/if}\n          {file.name}\n        </label>\n        <div class=\"field\">\n          <DynamicSelect bind:intext={lcdata.samples[file.associd].samplename} fixedoptions={projsamples} bind:unknowninput={lcdata.samples[file.associd].newprojsample} bind:selectval={lcdata.samples[file.associd].sample} on:selectedvalue={editMade} on:newvalue={e => checkNewSample(file)} niceName={x => x.name}/>\n        </div>\n      </td>\n      <td>\n        <div class=\"field\">\n          <div class=\"control\">\n            <p class={lcdata.samples[file.associd].badChannel ? 'control has-icons-left': ''}>\n            {#if lcdata.quanttype}\n            <DynamicSelect bind:intext={lcdata.samples[file.associd].channelname} niceName={x=>x.name} bind:fixedoptions={lcdata.quants[lcdata.quanttype].chans} bind:fixedorder={lcdata.quants[lcdata.quanttype].chanorder} bind:selectval={lcdata.samples[file.associd].channel} on:selectedvalue={e => okChannel(file.associd)} on:illegalvalue={e => badChannel(file.associd)} />\n\n            {#if lcdata.samples[file.associd].badChannel}\n        <span class=\"icon is-left has-text-danger\">\n          <i class=\"fas fa-asterisk\"></i>\n        </span>\n            {/if}\n            {/if}\n            </p>\n          </div>\n        </div>\n      </td>\n    </tr>\n    {/if}\n    {/each}\n  </tbody>\n  {/if}\n</table>\n","<script>\n\nimport { onMount } from 'svelte';\nimport { getJSON, postJSON } from './funcJSON.js'\nimport { dataset_id, datasetFiles } from './stores.js';\n\nlet files = {\n  newFiles: {},\n  dsfn_order: [],\n  newfn_order: [],\n};\nlet addedFiles = {};\nlet removed_files = {};\nlet findQuery = '';\nlet allDsSelector = false;\nlet allNewSelector = false;\n\nasync function findFiles(event) {\n  if (event.keyCode === 13) {\n    const response = await getJSON(`/datasets/find/files?q=${findQuery.split(' ').join(',')}`);\n    for (let [key, val] of Object.entries(response)) { files[key] = val; }\n  }\n}\n\nfunction isoTime(timestamp) {\n  let x = new Date(timestamp);\n  return x.toISOString();\n}\n\nfunction selectAllNew() {\n  let select_state = allNewSelector === false;\n  for (let fnid in files.newFiles) {\n    files.newFiles[fnid].checked = select_state;\n  }\n}\n\n$: changed = Object.keys(addedFiles).length || Object.keys(removed_files).length;\n$: selectedFiles = Object.values(files.newFiles).concat(Object.values(removed_files)).filter(fn => fn.checked);\n\nfunction deleteFile(fnid) {\n  if (fnid in $datasetFiles) {\n    removed_files[fnid] = $datasetFiles[fnid]\n    files.dsfn_order = files.dsfn_order.filter(x => x !== fnid);\n  } else if (fnid in addedFiles) {\n    addedFiles = Object.fromEntries(Object.entries(addedFiles).filter(x => x[1].id !== fnid));\n  }\n}\n\nfunction addFiles() {\n  for (let fn of Object.values(removed_files).filter(fn => fn.checked)) {\n    fn.checked = false;\n    //removed_files = file.removed_files.filter[fn.id] = fn;\n    delete(removed_files[fn.id]);\n    files.dsfn_order = [fn.id].concat(files.dsfn_order);\n    //files.newfn_order = files.newfn_order.filter(fnid => fnid !== fn.id);\n  }\n  for (let fn of Object.values(files.newFiles).filter(fn => fn.checked)) {\n    fn.checked = false;\n    addedFiles[fn.id] = fn;\n    files.newfn_order = files.newfn_order.filter(fnid => fnid !== fn.id);\n    //delete(files.newFiles[fn.id]);\n  }\n}\n\nasync function save() {\n  let url = '/datasets/save/files/';\n  let postdata = {\n    dataset_id: $dataset_id,\n    added_files: addedFiles,\n    removed_files: removed_files,\n  };\n  await postJSON(url, postdata);\n  fetchFiles();\n}\n\nasync function fetchFiles() {\n  let url = '/datasets/show/files/';\n  url = $dataset_id ? url + $dataset_id : url;\n\tconst response = await getJSON(url);\n  for (let [key, val] of Object.entries(response)) { files[key] = val; }\n  for (let key in $datasetFiles) { delete($datasetFiles[key]); }\n  for (let [key, val] of Object.entries(response.datasetFiles)) { $datasetFiles[key] = val; }\n  addedFiles = {};\n  removed_files = {};\n}\n\nonMount(async() => {\n  fetchFiles();\n});\n\n</script>\n\n<div class=\"content is-small\">\n  <input class=\"input is-small\" on:keyup={findFiles} bind:value={findQuery} type=\"text\" placeholder=\"Type a query and press enter to find analyses\">\n  <div>Showing {files.newfn_order.length} new files ({selectedFiles.length} selected), {files.dsfn_order.length} files in dataset (incl. {Object.keys(removed_files).length}, excl. {Object.keys(addedFiles).length} added files)</div>\n  <div>\n    <button on:click={save} class=\"button is-danger is-small\" disabled={!changed}>Save</button>\n    <button on:click={fetchFiles} class=\"button is-info is-small\">Revert</button>\n    <button on:click={addFiles} class=\"button is-small\" disabled={!selectedFiles.length} >Add selected files</button>\n  </div>\n  <table class=\"table\">\n    <thead>\n      <tr>\n        <th><input type=\"checkbox\" bind:checked={allNewSelector} on:click={selectAllNew}></th>\n        <th></th>\n        <th>File</th>\n        <th>Date</th>\n        <th>Size</th>\n        <th>Instrument</th>\n      </tr>\n    </thead> \n    <tbody>\n      \n      {#each Object.values(addedFiles).concat(files.dsfn_order.map(x => $datasetFiles[x])) as fn}\n      <tr>\n        <td><span on:click={e => deleteFile(fn.id)} class=\"icon is-small has-text-danger\"><i class=\"fas fa-times\"></i></span></td>\n        <td>\n          {#if fn.id in $datasetFiles}\n          <span class=\"icon is-small has-text-primary\"><i class=\"fas fa-database\"></i></span>\n          {/if}\n        </td>\n        <td>{fn.name}</td>\n        <td>{isoTime(fn.date)}</td>\n        <td>{fn.size}MB</td>\n        <td>{fn.instrument}</td>\n      </tr>\n      {/each}\n      {#each Object.values(removed_files).concat(files.newfn_order.map(x => files.newFiles[x])) as fn}\n      <tr>\n        <td>\n          <input type=\"checkbox\" bind:checked={fn.checked}>\n        </td>\n        <td></td>\n        <td>{fn.name}</td>\n        <td>{isoTime(fn.date)}</td>\n        <td>{fn.size}MB</td>\n        <td>{fn.instrument}</td>\n      </tr>\n      {/each}\n    </tbody>\n  </table>\n</div>\n","<script>\nimport { getJSON, postJSON } from './funcJSON.js'\nimport { dataset_id, datatype_id, datasetFiles, projsamples } from './stores.js';\nimport { onMount } from 'svelte';\nimport Acquicomp from './Acquicomp.svelte';\nimport Prepcomp from './Prepcomp.svelte';\nimport Msdata from './Msdata.svelte';\nimport LCheck from './LCheck.svelte';\nimport Files from './Files.svelte';\nimport ErrorNotif from './ErrorNotif.svelte';\n  \n// FIXME dataset_id is global on django template and not updated on save, change that!, FIXED???\n// FIXME files do not get updated\nif (init_dataset_id) { dataset_id.set(init_dataset_id) };\n\n\nlet mssubcomp;\nlet acquicomp;\nlet prepcomp;\nlet lccomp;\nlet filescomp;\nlet edited = false;\nlet errors = {\n  basics: [],\n  sprep: [],\n  acqui: [],\n  lc: [],\n};\nlet saveerrors = Object.assign({}, errors);\nlet comperrors = [];\n\n\nlet dsinfo = {\n  datatype_id: '',\n  project_id: '',\n  ptype_id: '',\n  storage_location: '',\n  newprojectname: '',\n  experiment_id: '',\n  runname: '',\n  pi: '',\n  externalcontactmail: '',\n  prefrac_id: '',\n  prefrac_length: '',\n  prefrac_amount: '',\n  hiriefrange: '',\n}\n\nlet pdata = {\n  datasettypes: [],\n  ptypes: [],\n  projects: [],\n  local_ptype_id: '',\n  external_pis: [],\n  prefracs: [],\n  hirief_ranges: [],\n}\n\nlet components = [];\nlet isNewProject = false;\nlet isNewExperiment = false;\nlet isNewPI = false;\nlet experiments = []\nlet stored = true;\nlet tabshow = 'meta';\nlet tabcolor = 'has-text-grey-lighter';\n  // Yes, for microscopy/genomics, we need separation between samples/prep\n  // files is given, and possibly samples as well, check it out but samples is needed for:\n  // - QMS, LCheck?, IP, TPP, microscopy, QC?, genomics\n\n$: showMsdata = components.indexOf('acquisition') > -1;\n$: isExternal = dsinfo.ptype_id && dsinfo.ptype_id !== pdata.local_ptype_id;\n\nasync function getcomponents() {\n  const result = await getJSON(`/datasets/show/components/${dsinfo.datatype_id}`);\n  components = result.components;\n}\n\nasync function project_selected(event=false, saved=false) {\n  if (dsinfo.project_id) {\n    const result = await getJSON(`/datasets/show/project/${dsinfo.project_id}`);\n    dsinfo.pi = pdata.external_pis.filter(pi => pi.id === result.pi_id)[0];\n    dsinfo.ptype_id = result.ptype_id;\n    experiments = result.experiments;\n    for (let key in projsamples) { delete(projsamples[key]);};\n    for (let [key, val] of Object.entries(result.projsamples)) { projsamples[key] = val; }\n    isNewProject = false;\n  }\n  if (!saved) {\n    dsinfo.experiment_id = '';\n  }\n  editMade();\n}\n\nfunction toggle_project() {\n  isNewProject = isNewProject === false;\n}\n\nfunction editMade() {\n  edited = true;\n  errors.basics = errors.basics.length ? validate() : [];\n}\n\nasync function fetchDataset() {\n  let url = '/datasets/show/info/';\n  url = $dataset_id ? url + $dataset_id : url;\n\tconst response = await getJSON(url);\n  for (let [key, val] of Object.entries(response.projdata)) { pdata[key] = val; }\n  for (let [key, val] of Object.entries(response.dsinfo)) { dsinfo[key] = val; }\n  if ($dataset_id) {\n    getcomponents();\n    await project_selected(false, true); // false is event, true is saved param\n    isNewExperiment = false;\n    isNewPI = false;\n  }\n  edited = false;\n}\n\nfunction validate() {\n\tcomperrors = [];\n\tconst re = RegExp('^[a-z0-9-_]+$', 'i');\n\tif ((isNewProject && !dsinfo.newprojectname) || (!isNewProject && !dsinfo.project_id)) {\n\t\tcomperrors.push('Project needs to be selected or created');\n\t}\n\telse if (isNewProject && dsinfo.newprojectname && !re.test(dsinfo.newprojectname)) {\n\t\tcomperrors.push('Project name may only contain a-z 0-9 - _');\n\t}\n\tif (!dsinfo.runname) {\n\t\tcomperrors.push('Run name is required');\n\t}\n\telse if (!re.test(dsinfo.runname)) {\n\t\tcomperrors.push('Run name may only contain a-z 0-9 - _');\n\t}\n  if (showMsdata && ((isNewExperiment && !dsinfo.newexperimentname) || (!isNewExperiment && !dsinfo.experiment_id))) {\n\t\tcomperrors.push('Experiment is required');\n\t}\n\telse if (showMsdata && isNewExperiment && dsinfo.newexperimentname && !re.test(dsinfo.newexperimentname)) {\n\t\tcomperrors.push('Experiment name may only contain a-z 0-9 - _');\n\t}\n  if (isExternal) {\n\t\tif (!dsinfo.newpiname && !dsinfo.pi.id) {\n\t\t\tcomperrors.push('Need to select or create a PI');\n\t\t}\n\t\tif (!dsinfo.externalcontactmail) {\n\t\t\tcomperrors.push('External contact is required');\n\t\t}\n\t}\n  // This is probably not possible to save in UI, button is disabled\n\tif (!dsinfo.datatype_id) {\n\t\tcomperrors.push('Datatype is required');\n\t}\n  return comperrors;\n}\n\nasync function save() {\n  errors.basics = validate();\n  if (showMsdata) { \n    let mserrors = mssubcomp.validate();\n    errors.basics = [...errors.basics, ...mserrors];\n  }\n  if (errors.basics.length === 0) { \n    let postdata = {\n      dataset_id: $dataset_id,\n      ptype_id: dsinfo.ptype_id,\n      datatype_id: dsinfo.datatype_id,\n      runname: dsinfo.runname,\n      prefrac_id: dsinfo.prefrac_id,\n      prefrac_length: dsinfo.prefrac_length,\n      prefrac_amount: dsinfo.prefrac_amount,\n      hiriefrange: dsinfo.hiriefrange,\n    };\n    if (isNewProject) {\n      postdata.newprojectname = dsinfo.newprojectname;\n    } else {\n      postdata.project_id = dsinfo.project_id;\n    }\n    if (isNewExperiment) {\n      postdata.newexperimentname = dsinfo.newexperimentname;\n    } else {\n      postdata.experiment_id = dsinfo.experiment_id;\n    }\n    if (isNewPI) {\n      postdata.newpiname = dsinfo.newpiname;\n    } else {\n      postdata.pi_id = isExternal ? dsinfo.pi.id : pdata.internal_pi_id;\n    }\n    if (dsinfo.ptype_id !== pdata.local_ptype_id) {\n      postdata.externalcontact = dsinfo.externalcontactmail;\n    }\n    const response = await postJSON('/datasets/save/project/', postdata);\n    if ('error' in response) {\n      saveerrors.basics = [response.error, ...saveerrors.basics];\n    } else {\n  \t  dataset_id.set(response.dataset_id);\n      console.log($dataset_id);\n      fetchDataset();\n    }\n  }\n}\n\nonMount(async() => {\n  await fetchDataset();\n})\n\nfunction showMetadata() {\n  tabshow = 'meta';\n}\n\nfunction showFiles() {\n  tabshow = $dataset_id ? 'files' : tabshow;\n}\n\n</script>\n\n\n<ErrorNotif cssclass=\"sticky\" errors={Object.values(saveerrors).flat().concat(Object.values(errors).flat())} />\n<!--\n{#if Object.values(errors).flat().length || Object.values(saveerrors).flat().length}\n<div class=\"notification errorbox is-danger\">\n  <ul>\n    {#each Object.values(saveerrors).flat() as error}\n    <li>&bull; {error}</li>\n    {/each}\n    {#each Object.values(errors).flat() as error}\n    <li>&bull; {error}</li>\n    {/each}\n  </ul>\n</div>\n{/if}\n-->\n\n<div class=\"tabs is-toggle is-centered is-small\">\n\t<ul>\n    <li class={tabshow === 'meta' ? 'is-active': ''}><a on:click={showMetadata}>\n        <span>Metadata</span>\n    </li>\n    {#if $dataset_id}\n    <li class={tabshow === 'files' ? 'is-active': ''}><a on:click={showFiles}>\n        <span>Files</span>\n    </li>\n    {/if}\n\t</ul>\n</div>\n\n<h4 class=\"title is-4\">Dataset</h4> \n<div style=\"display: {tabshow !== 'meta' ? 'none' : ''}\">\n    <div class=\"box\" id=\"project\">\n    \n      {#if dsinfo.storage_location}\n    \t<article class=\"message is-info\"> \n        <div class=\"message-header\">Storage location</div>\n        <div class=\"message-body\">{dsinfo.storage_location}</div>\n    \t</article>\n      {/if}\n    \n      <h5 class=\"has-text-primary title is-5\">\n        {#if stored}\n        <i class=\"icon fas fa-check-circle\"></i>\n        {/if}\n        Basics\n        <button class=\"button is-small is-danger has-text-weight-bold\" disabled={!edited} on:click={save}>Save</button>\n        <button class=\"button is-small is-info has-text-weight-bold\" disabled={!edited || !dsinfo.datatype_id} on:click={fetchDataset}>Revert</button>\n      </h5>\n    \n      <div class=\"field\"> \n        <label class=\"label\">Project\n          <a class=\"button is-danger is-outlined is-small\" on:click={toggle_project}>\n            {#if isNewProject}\n            Use existing project\n            {:else}\n            Create new project\n            {/if}\n          </a>\n        </label>\n        <div class=\"control\">\n        {#if !isNewProject}\n          <div class=\"select\">\n            <select bind:value={dsinfo.project_id} on:change={project_selected}>\n              <option disabled value=\"\">Please select one</option>\n              {#each pdata.projects as project}\n              <option value={project.id}>{project.name}</option>\n              {/each}\n            </select>\n          </div>\n        {:else}\n        <input class=\"input\" bind:value={dsinfo.newprojectname} type=\"text\" placeholder=\"Project name\" on:change={editMade}>\n        <label class=\"label\">Project type</label>\n        <div class=\"select\">\n          <select bind:value={dsinfo.ptype_id}>\n            <option disabled value=\"\">Please select one</option>\n            {#each pdata.ptypes as ptype}\n            <option value={ptype.id}>{ptype.name}</option>\n            {/each}\n          </select>\n        </div>\n        {/if}\n        {#if isExternal}\n        <span class=\"tag is-success is-medium\">External project: {dsinfo.pi.name}</span>\n        {/if}\n        </div>\n      </div>\n\n      {#if isExternal}\n      <div class=\"field\">\n        <label class=\"label\">contact(s)\n          {#if isNewProject && isNewPI}\n          <a class=\"button is-danger is-outlined is-small\" on:click={e => isNewPI = !isNewPI}>Use existing PI</a>\n          {:else if isNewProject}\n          <a class=\"button is-danger is-outlined is-small\" on:click={e => isNewPI = !isNewPI}>Create new PI</a>\n          {/if}\n        </label>\n        {#if isNewProject && !isNewPI}\n        <div class=\"control\">\n          <div class=\"select\">\n            <select on:change={editMade} bind:value={dsinfo.pi}>\n\t\t\t\t\t  \t<option disabled value=\"\">Please select one</option>\n              {#each pdata.external_pis as expi}\n              <option value={expi}>{expi.name}</option>\n              {/each}\n\t\t\t\t\t  </select>\n\t\t\t\t  </div>\n\t\t\t  </div>\n        {:else if isNewProject}\n        <div class=\"control\">\n          <input class=\"input\" on:input={editMade} bind:value={dsinfo.newpiname} type=\"text\" placeholder=\"PI name\">\n        </div>\n        {/if}\n        <div class=\"control\">\n          <input class=\"input\" type=\"text\" on:change={editMade} bind:value={dsinfo.externalcontactmail} placeholder=\"operational contact email (e.g. postdoc)\">\n        </div>\n      </div>\n      {/if}\n    \n      <div class=\"field\">\n        <label class=\"label\">Dataset type</label>\n        <div class=\"control\">\n          <div class=\"select\">\n            <select bind:value={dsinfo.datatype_id} on:change={getcomponents}>\n              <option disabled value=\"\">Please select one</option>\n              {#each pdata.datasettypes as dstype}\n              <option value={dstype.id}>{dstype.name}</option>\n              {/each}\n            </select>\n          </div>\n        </div>\n      </div>\n\n      {#if showMsdata}\n      <Msdata bind:this={mssubcomp} on:edited={editMade} bind:dsinfo={dsinfo} bind:isNewExperiment={isNewExperiment} experiments={experiments} prefracs={pdata.prefracs} hirief_ranges={pdata.hirief_ranges} />\n\n      <div class=\"field\">\n        <label class=\"label\">Run name</label>\n        <div class=\"control\">\n          <input class=\"input\" bind:value={dsinfo.runname} on:change={editMade} type=\"text\" placeholder=\"E.g set1, lc3, rerun5b, etc\">\n        </div>\n      </div>\n\n      <Acquicomp bind:this={acquicomp} bind:errors={errors.acqui} />\n      {:else if dsinfo.datatype_id}\n      <div class=\"field\">\n        <label class=\"label\">Run name</label>\n        <div class=\"control\">\n          <input class=\"input\" bind:value={dsinfo.runname} on:change={editMade} type=\"text\" placeholder=\"E.g set1, lc3, rerun5b, etc\">\n        </div>\n      </div>\n      {/if}\n      {#if (components.indexOf('sampleprep')> -1)}\n      <Prepcomp bind:this={prepcomp} bind:errors={errors.sprep} />\n      {/if}\n      {#if (Object.keys($datasetFiles).length && components.indexOf('labelchecksamples')>-1)}\n      <LCheck bind:this={lccomp} bind:errors={errors.lc} />\n      {/if}\n    </div>\n</div>\n\n<div style=\"display: {tabshow !== 'files' ? 'none' : ''}\">\n    <Files bind:this={filescomp} />\n</div>\n","import App from './App.svelte';\n\nvar app = new App({\n\ttarget: document.querySelector('#appbox')\n});\n\nexport default app;\n"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","component_subscribe","component","store","callback","$$","on_destroy","push","unsub","subscribe","unsubscribe","null_to_empty","value","set_store_value","ret","set","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","i","length","d","element","name","document","createElement","text","data","createTextNode","space","empty","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","removeAttribute","setAttribute","to_number","undefined","set_data","set_input_value","input","set_style","key","important","style","setProperty","select_option","select","option","__value","selected","select_value","selected_option","querySelector","current_component","set_current_component","onMount","Error","get_current_component","on_mount","createEventDispatcher","type","detail","callbacks","e","createEvent","initCustomEvent","custom_event","slice","call","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","add_flush_callback","flush","seen_callbacks","Set","shift","update","pop","has","add","fragment","dirty","before_update","p","ctx","after_update","outroing","outros","group_outros","r","c","check_outros","transition_in","block","local","delete","transition_out","o","globals","window","global","bind","props","indexOf","bound","mount_component","m","new_on_destroy","map","filter","destroy_component","make_dirty","then","init","instance","create_fragment","not_equal","prop_names","parent_component","context","Map","ready","hydrate","l","Array","from","childNodes","intro","SvelteComponent","[object Object]","this","$destroy","index","splice","async","parseResponse","response","jsonresp","json","error","ok","status","getJSON","url","fetch","postJSON","postdata","method","headers","Content-Type","body","JSON","stringify","subscriber_queue","writable","start","stop","subscribers","new_value","run_queue","s","invalidate","subscriber","dataset_id","datasetFiles","projsamples","param","fields","placeholder","edited","model","checked","title","inputtype","dispatch","errors","cssclass","operator","id","editMade","dsinfo","rp_length","stored","acquierrors","acqdata","operators","dynamic_rp","entries","params","operator_id","save","fetchData","validate","comperrors","$dataset_id","val","message","keys","optorder","niceName","optid","fetchOptions","starttyping","inputdone","intext","typing","selectval","fixedoptions","fixedorder","fromEntries","fetchUrl","unknowninput","deselect","ev","selectvalue","hovervalue","console","log","x","toLowerCase","toString","niceSpecies","spec","click_handler","prepdata","enzymes","enzyme","quant","isLabelfree","labelfree_multisample","foundNewSamples","$datasetFiles","parseSampleNames","trysamplenames","checkIfNewSamples","saveNewSamples","labelfree_singlesample","newprojsample","values","quants","quanttype","chans","sample","s_id","file","samples","associd","change_handler_2","change_handler_3","channel","change_handler","change_handler_1","preperrors","allspecies","selectedspecies","addOrganism","species","no_enzyme","nice","linnean","labelfree_quant_id","removeOrganism","org_id","some","ch","checkNewSampleLabelfree","uppername","trim","toUpperCase","found","checkNewSampleIso","chanix","resetNewSampleName","chan_or_sample","doSampleSave","ch_or_samfn","ix","samplename","psid","psname","f","Number","assocs","checkSamplesIfNewFiles","ixmap","fnmap","line","split","nps","aid","saves","savedsample","samfn","item","labelfree","filenames","experiments","experiment_id","newexperimentname","exp","prefrac","prefrac_length","hirief_ranges","hiriefrange","range","prefrac_amount","isNewExperiment","prefracs","hiriefselected","prefrac_id","toggle_experiment","pf","lcdata","func","badChannel","func_1","channelname","chanorder","lcerrors","okChannel","fid","checkNewSample","parseInt","isoTime","date","size","instrument","files","newfn_order","selectedFiles","dsfn_order","removed_files","addedFiles","concat","changed","findFiles","fetchFiles","addFiles","selectAllNew","findQuery","allNewSelector","timestamp","Date","toISOString","newFiles","deleteFile","fnid","keyCode","join","select_state","added_files","tabshow","showFiles","storage_location","pdata","ptypes","ptype_id","newprojectname","projects","project_id","project_selected","ptype","project","pi","isNewProject","isNewPI","externalcontactmail","newpiname","external_pis","expi","dstype","runname","acqui","sprep","lc","components","saveerrors","flat","datasettypes","showMsdata","datatype_id","showMetadata","fetchDataset","toggle_project","getcomponents","isExternal","mssubcomp","acquicomp","prepcomp","lccomp","filescomp","init_dataset_id","basics","assign","local_ptype_id","result","saved","pi_id","projdata","re","RegExp","test","mserrors","internal_pi_id","externalcontact"],"mappings":"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"}