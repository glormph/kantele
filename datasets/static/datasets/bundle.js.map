{"version":3,"file":"bundle.js","sources":["../../../frontend/datasets/node_modules/svelte/internal/index.mjs","../../../frontend/datasets/src/funcJSON.js","../../../frontend/datasets/node_modules/svelte/store/index.mjs","../../../frontend/datasets/src/stores.js","../../../frontend/datasets/src/Param.svelte","../../../frontend/datasets/src/ErrorNotif.svelte","../../../frontend/datasets/src/Acquicomp.svelte","../../../frontend/datasets/src/DynamicSelect.svelte","../../../frontend/datasets/src/Prepcomp.svelte","../../../frontend/datasets/src/Msdata.svelte","../../../frontend/datasets/src/LCheck.svelte","../../../frontend/datasets/src/PooledLCheck.svelte","../../../frontend/datasets/src/Files.svelte","../../../frontend/datasets/src/App.svelte","../../../frontend/datasets/src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction validate_store(store, name) {\n    if (!store || typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, callback) {\n    const unsub = store.subscribe(callback);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, fn) {\n    return definition[1]\n        ? assign({}, assign(ctx.$$scope.ctx, definition[1](fn ? fn(ctx) : {})))\n        : ctx.$$scope.ctx;\n}\nfunction get_slot_changes(definition, ctx, changed, fn) {\n    return definition[1]\n        ? assign({}, assign(ctx.$$scope.changed || {}, definition[1](fn ? fn(changed) : {})))\n        : ctx.$$scope.changed || {};\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value = ret) {\n    store.set(value);\n    return ret;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nlet running = false;\nfunction run_tasks() {\n    tasks.forEach(task => {\n        if (!task[0](now())) {\n            tasks.delete(task);\n            task[1]();\n        }\n    });\n    running = tasks.size > 0;\n    if (running)\n        raf(run_tasks);\n}\nfunction clear_loops() {\n    // for testing...\n    tasks.forEach(task => tasks.delete(task));\n    running = false;\n}\nfunction loop(fn) {\n    let task;\n    if (!running) {\n        running = true;\n        raf(run_tasks);\n    }\n    return {\n        promise: new Promise(fulfil => {\n            tasks.add(task = [fn, fulfil]);\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    // eslint-disable-next-line @typescript-eslint/no-object-literal-type-assertion\n    const target = {};\n    for (const k in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    for (const key in attributes) {\n        if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key in node) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group) {\n    const value = [];\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.push(group[i].__value);\n    }\n    return value;\n}\nfunction to_number(value) {\n    return value === '' ? undefined : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeName === name) {\n            for (let j = 0; j < node.attributes.length; j += 1) {\n                const attribute = node.attributes[j];\n                if (!attributes[attribute.name])\n                    node.removeAttribute(attribute.name);\n            }\n            return nodes.splice(i, 1)[0]; // TODO strip unwanted attributes\n        }\n    }\n    return svg ? svg_element(name) : element(name);\n}\nfunction claim_text(nodes, data) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 3) {\n            node.data = '' + data;\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return text(data);\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.data !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    if (value != null || input.value) {\n        input.value = value;\n    }\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\nfunction add_resize_listener(element, fn) {\n    if (getComputedStyle(element).position === 'static') {\n        element.style.position = 'relative';\n    }\n    const object = document.createElement('object');\n    object.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;');\n    object.type = 'text/html';\n    object.tabIndex = -1;\n    let win;\n    object.onload = () => {\n        win = object.contentDocument.defaultView;\n        win.addEventListener('resize', fn);\n    };\n    if (/Trident/.test(navigator.userAgent)) {\n        element.appendChild(object);\n        object.data = 'about:blank';\n    }\n    else {\n        object.data = 'about:blank';\n        element.appendChild(object);\n    }\n    return {\n        cancel: () => {\n            win && win.removeEventListener && win.removeEventListener('resize', fn);\n            element.removeChild(object);\n        }\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, false, false, detail);\n    return e;\n}\nclass HtmlTag {\n    constructor(html, anchor = null) {\n        this.e = element('div');\n        this.a = anchor;\n        this.u(html);\n    }\n    m(target, anchor = null) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(target, this.n[i], anchor);\n        }\n        this.t = target;\n    }\n    u(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    p(html) {\n        this.d();\n        this.u(html);\n        this.m(this.t, this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\n\nlet stylesheet;\nlet active = 0;\nlet current_rules = {};\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    if (!current_rules[name]) {\n        if (!stylesheet) {\n            const style = element('style');\n            document.head.appendChild(style);\n            stylesheet = style.sheet;\n        }\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    node.style.animation = (node.style.animation || '')\n        .split(', ')\n        .filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    )\n        .join(', ');\n    if (name && !--active)\n        clear_rules();\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        let i = stylesheet.cssRules.length;\n        while (i--)\n            stylesheet.deleteRule(i);\n        current_rules = {};\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error(`Function called outside component initialization`);\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = current_component;\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        callbacks.slice().forEach(fn => fn(event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nfunction flush() {\n    const seen_callbacks = new Set();\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        while (dirty_components.length) {\n            const component = dirty_components.shift();\n            set_current_component(component);\n            update(component.$$);\n        }\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                callback();\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n}\nfunction update($$) {\n    if ($$.fragment) {\n        $$.update($$.dirty);\n        run_all($$.before_update);\n        $$.fragment.p($$.dirty, $$.ctx);\n        $$.dirty = null;\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = program.b - t;\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = key && { [key]: value };\n        const child_ctx = assign(assign({}, info.ctx), info.resolved);\n        const block = type && (info.current = type)(child_ctx);\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            info.blocks[i] = null;\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            flush();\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = { [info.value]: promise };\n    }\n}\n\nconst globals = (typeof window !== 'undefined' ? window : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, changed, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(changed, child_ctx);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction measure(blocks) {\n    const rects = {};\n    let i = blocks.length;\n    while (i--)\n        rects[blocks[i].key] = blocks[i].node.getBoundingClientRect();\n    return rects;\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args) {\n    const attributes = Object.assign({}, ...args);\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === undefined)\n            return;\n        if (value === true)\n            str += \" \" + name;\n        const escaped = String(value)\n            .replace(/\"/g, '&#34;')\n            .replace(/'/g, '&#39;');\n        str += \" \" + name + \"=\" + JSON.stringify(escaped);\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, options = {}) => {\n            on_destroy = [];\n            const result = { head: '', css: new Set() };\n            const html = $$render(result, props, {}, options);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : ``;\n}\n\nfunction bind(component, name, callback) {\n    if (component.$$.props.indexOf(name) === -1)\n        return;\n    component.$$.bound[name] = callback;\n    callback(component.$$.ctx[name]);\n}\nfunction mount_component(component, target, anchor) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment.m(target, anchor);\n    // onMount happens before the initial afterUpdate\n    add_render_callback(() => {\n        const new_on_destroy = on_mount.map(run).filter(is_function);\n        if (on_destroy) {\n            on_destroy.push(...new_on_destroy);\n        }\n        else {\n            // Edge case - component was destroyed immediately,\n            // most likely as a result of a binding initialising\n            run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n    });\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    if (component.$$.fragment) {\n        run_all(component.$$.on_destroy);\n        component.$$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        component.$$.on_destroy = component.$$.fragment = null;\n        component.$$.ctx = {};\n    }\n}\nfunction make_dirty(component, key) {\n    if (!component.$$.dirty) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty = blank_object();\n    }\n    component.$$.dirty[key] = true;\n}\nfunction init(component, options, instance, create_fragment, not_equal, prop_names) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const props = options.props || {};\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props: prop_names,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : []),\n        // everything else\n        callbacks: blank_object(),\n        dirty: null\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, props, (key, ret, value = ret) => {\n            if ($$.ctx && not_equal($$.ctx[key], $$.ctx[key] = value)) {\n                if ($$.bound[key])\n                    $$.bound[key](value);\n                if (ready)\n                    make_dirty(component, key);\n            }\n            return ret;\n        })\n        : props;\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    $$.fragment = create_fragment($$.ctx);\n    if (options.target) {\n        if (options.hydrate) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment.l(children(options.target));\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor);\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement !== 'undefined') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set() {\n            // overridden by instance, if it has props\n        }\n    };\n}\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set() {\n        // overridden by instance, if it has props\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, detail));\n}\nfunction append_dev(target, node) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node });\n    append(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev(\"SvelteDOMRemove\", { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? [\"capture\"] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev(\"SvelteDOMAddEventListener\", { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev(\"SvelteDOMRemoveEventListener\", { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev(\"SvelteDOMRemoveAttribute\", { node, attribute });\n    else\n        dispatch_dev(\"SvelteDOMSetAttribute\", { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev(\"SvelteDOMSetProperty\", { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev(\"SvelteDOMSetDataset\", { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    dispatch_dev(\"SvelteDOMSetData\", { node: text, data });\n    text.data = data;\n}\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(`'target' is a required option`);\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn(`Component was already destroyed`); // eslint-disable-line no-console\n        };\n    }\n}\n\nexport { HtmlTag, SvelteComponent, SvelteComponentDev, SvelteElement, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, assign, attr, attr_dev, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_element, claim_space, claim_text, clear_loops, component_subscribe, createEventDispatcher, create_animation, create_bidirectional_transition, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, escape, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getContext, get_binding_group_value, get_current_component, get_slot_changes, get_slot_context, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, identity, init, insert, insert_dev, intros, invalid_attribute_name_character, is_client, is_function, is_promise, listen, listen_dev, loop, measure, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, update_keyed_each, validate_component, validate_store, xlink_attr };\n","async function parseResponse(response) {\n  let jsonresp;\n  try {\n    jsonresp = await response.json();\n  } catch(error) {\n    // Non-JSON responses, e.g. HTTP 500 server crash\n    return {ok: false, error: 'Server error encountered', status: response.status};\n  }\n  // Deliver HTTP errors if any\n  jsonresp.ok = response.ok;\n  return jsonresp;\n}\n\n\nexport async function getJSON(url) {\n  let response;\n  try {\n    response = await fetch(url);\n  } catch {\n      return {ok: false, error: 'Kantele encountered a network error', status: false}\n  }\n  return await parseResponse(response);\n}\n\n\nexport async function postJSON(url, postdata) {\n  let response;\n  try {\n    response = await fetch(url, {\n      method: 'POST', headers: {\n        'Content-Type': 'application/json'\n      }, body: JSON.stringify(postdata)\n    });\n  } catch {\n    return {ok: false, error: 'Kantele encountered a network error', status: false}\n  }\n  return await parseResponse(response);\n}\n","import { safe_not_equal, noop, run_all, is_function } from '../internal';\nexport { get_store_value as get } from '../internal';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe,\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = [];\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (let i = 0; i < subscribers.length; i += 1) {\n                    const s = subscribers[i];\n                    s[1]();\n                    subscriber_queue.push(s, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.push(subscriber);\n        if (subscribers.length === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            const index = subscribers.indexOf(subscriber);\n            if (index !== -1) {\n                subscribers.splice(index, 1);\n            }\n            if (subscribers.length === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n * @param {Stores} stores input stores\n * @param {function(Stores=, function(*)=):*}fn function callback that aggregates the values\n * @param {*=}initial_value when used asynchronously\n */\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => store.subscribe((value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","import { writable } from 'svelte/store';\n\nexport const dataset_id = writable(false);\n\nexport const datatype_id = writable('');\n\nexport const datasetFiles = writable({});\n\nexport const projsamples = writable({});\n\n","<script>\nimport { createEventDispatcher } from 'svelte';\nconst dispatch = createEventDispatcher();\n\nexport let param;\n\nfunction edited() { dispatch('edited');}\n\n</script>\n\n<div class=\"field\">\n  <label class=\"label\">{param.title}</label>\n  <div class=\"control\">\n    {#if param.inputtype === 'select'}\n    <div class=\"select\"> \n      <select bind:value={param.model} on:change={edited}>\n        <option disabled value=\"\">Please select one</option>\n        {#each param.fields as option}\n        <option value={option.value}>{option.text}</option>\n        {/each}\n      </select>\n    </div>\n    {:else if param.inputtype === 'text'}\n    <input type=\"text\" class=\"input\" placeholder={param.placeholder} bind:value={param.model} on:change={edited}>\n    {:else if param.inputtype === 'number'}\n    <input type=\"number\" class=\"input\" placeholder={param.placeholder} bind:value={param.model} on:change={edited}>\n    {:else if param.inputtype === 'checkbox'}\n    {#each param.fields as option}\n    <div class=\"control\">\n      <input bind:checked={option.checked} on:change={edited} type=\"checkbox\">{option.text}\n    </div>\n    {/each}\n    {/if}\n  </div>\n</div>\n","<script>\n\nexport let errors;\nexport let cssclass = '';\n</script>\n\n<style>\n  .sticky {\n    position: sticky;\n    position: -webkit-sticky;\n    top: 20px;\n    z-index: 1000;\n  }\n</style>\n\n{#if errors.length}\n<div class={`notification is-danger ${cssclass}`}>\n  <ul>\n    {#each errors as error}\n    <li>&bull; {error}</li>\n    {/each}\n  </ul>\n</div>\n{/if}\n","<script>\n\nimport { onMount } from 'svelte';\nimport { getJSON, postJSON } from './funcJSON.js'\nimport Param from './Param.svelte';\nimport ErrorNotif from './ErrorNotif.svelte';\nimport { dataset_id } from './stores.js';\n\nexport let errors;\n\nlet acquierrors = [];\n\n\nlet dsinfo = {\n  operator_id: '',\n  dynamic_rp: false,\n  rp_length: '',\n  params: [],\n}\n\nlet acqdata = {\n  operators: [],\n}\n\nlet edited = false;\n$: stored = $dataset_id && !edited;\n\nfunction editMade() { \n  errors = errors.length ? validate() : [];\n  edited = true;\n}\n\nexport function validate() {\n  let comperrors = [];\n\tif (!dsinfo.operator_id) {\n\t\tcomperrors.push('Operator is required');\n\t}\n\tif (!dsinfo.dynamic_rp && !dsinfo.rp_length) {\n\t\tcomperrors.push('Reverse phase is required');\n\t}\n\tfor (let key in dsinfo.params) {\n    if (dsinfo.params[key].model === undefined || dsinfo.params[key].model === '') {\n\t\t\tcomperrors.push(dsinfo.params[key].title + ' is required');\n\t\t}\n\t}\n  return comperrors;\n}\n\nexport async function save() {\n  acquierrors = [];\n  errors = validate();\n  if (errors.length === 0) { \n    let postdata = {\n      dataset_id: $dataset_id,\n      operator_id: dsinfo.operator_id,\n      params: dsinfo.params,\n      rp_length: dsinfo.dynamic_rp ? '' : dsinfo.rp_length,\n    };\n    let url = '/datasets/save/acquisition/';\n    try {\n      const resp = await postJSON(url, postdata);\n      fetchData();\n    } catch(error) {\n      if (error.message === '404') { \n        acquierrors = [...acquierrors, 'Save dataset before saving acquisition'];\n      }\n    }\n  }\n}\n\n\nasync function fetchData() {\n  let url = '/datasets/show/acquisition/';\n  url = $dataset_id ? url + $dataset_id : url;\n\tconst response = await getJSON(url);\n  for (let [key, val] of Object.entries(response.acqdata)) { acqdata[key] = val; }\n  for (let [key, val] of Object.entries(response.dsinfo)) { dsinfo[key] = val; }\n  edited = false;\n}\n\nonMount(async() => {\n  fetchData();\n})\n\n</script>\n\n<style>\n</style>\n\n<h5 class=\"has-text-primary title is-5\">\n  {#if stored}\n  <i class=\"icon fas fa-check-circle\"></i>\n  {:else if edited}\n  <i class=\"icon fas fa-edit\"></i>\n  {/if}\n  Acquisition\n  <button class=\"button is-small is-danger has-text-weight-bold\" disabled={!edited} on:click={save}>Save</button>\n  <button class=\"button is-small is-info has-text-weight-bold\" disabled={!edited} on:click={fetchData}>Revert</button>\n</h5>\n\n<ErrorNotif errors={acquierrors} />\n\n<div class=\"field\">\n  <label class=\"label\">Operator</label>\n  <div class=\"control\">\n    <div class=\"select\">\n      <select on:change={editMade} bind:value={dsinfo.operator_id}>\n        <option disabled value=\"\">Please select one</option>\n        {#each acqdata.operators as operator}\n        <option value={operator.id}>{operator.name}</option>\n        {/each}\n      </select>\n    </div>\n  </div>\n</div>\n\n<div class=\"field\">\n  <label class=\"label\">Reverse phase length</label>\n  <div class=\"control\">\n    <input type=\"checkbox\" on:change={editMade} bind:checked={dsinfo.dynamic_rp}>Dynamic\n    {#if !dsinfo.dynamic_rp}\n    <input type=\"number\" on:change={editMade} class=\"input\" placeholder=\"in minutes\" bind:value={dsinfo.rp_length}>\n    {/if}\n  </div>\n</div>\n\n{#each Object.entries(dsinfo.params) as [param_id, param]}\n<Param bind:param={param} on:edited={editMade}/>\n{/each}\n","<script>\nimport { getJSON } from './funcJSON.js';\nimport { createEventDispatcher } from 'svelte';\n\nconst dispatch = createEventDispatcher();\n\nexport let selectval = '';\nexport let fixedoptions = {};\nexport let fixedorder = [];\nexport let intext;\nexport let fetchUrl = false;\nexport let fetchedData;\nexport let niceName = function(text) { return text; }\nexport let unknowninput = '__ILLEGAL_PLACEHOLDER__';\n\nlet options;\n$: options = Object.fromEntries(Object.entries(fixedoptions));\nlet optorder = [];\nlet optorderindex;\n$: optorderindex = Object.fromEntries(optorder.map((x, ix) => [x, ix]));\n\nlet hoveropt = false;\nlet selectedtext;\nlet placeholder = 'Filter by typing';\nlet typing = false;\nlet mouseSelect = false;\nconst initval = selectval;\n\n\nfunction inputdone() {\n  console.log('inputdone');\n  if (!mouseSelect) {\n    typing = false;\n    if (selectval && selectval in options) {\n      intext = niceName(options[selectval]);\n    } else if (unknowninput === '__ILLEGAL_PLACEHOLDER__') {\n      console.log('illegal value dectected');\n      dispatch('illegalvalue', {});\n    } else {\n      unknowninput = intext;\n      dispatch('newvalue', {});\n    }\n  }\n}\n\n\nfunction selectvalue(optid) {\n  mouseSelect = false;\n  selectval = options[optid].id;\n  intext = niceName(options[selectval]);\n  if (unknowninput !== '__ILLEGAL_PLACEHOLDER__') {\n    unknowninput = '';\n  }\n  dispatch('selectedvalue', {});\n  inputdone();\n}\n\n\nasync function handleKeyInput(event) {\n  // Takes care of key inputs, characters and backspace/delete\n  if (event.keyCode === 27) {\n    // escape\n    mouseSelect = false;\n    inputdone();\n  } else if (hoveropt && (event.keyCode === 13 || event.keyCode === 9)) {\n    // return || tab pressed in hover\n    mouseSelect = false;\n    selectvalue(hoveropt);\n  } else if (!hoveropt && (event.keyCode === 13 || event.keyCode === 9)) {\n    // return || tab pressed in new value thing hover\n    inputdone();\n  } else if (optorder.length && event.keyCode === 40) {\n    // down arrow key\n    if (hoveropt && optorderindex[hoveropt] + 1 <= optorder.length) {\n      // else bottom line, do nothing\n      hoveropt = optorder[optorderindex[hoveropt] + 1];\n    } else if (!hoveropt) {\n      hoveropt = optorder[0];\n    }\n  } else if (optorder.length && event.keyCode === 38) {\n    // up arrow key\n    hoveropt = hoveropt && optorderindex[hoveropt] > 0 ? optorder[optorderindex[hoveropt] - 1] : false;\n  } else if (!intext.length) {\n    // empty input, show all options, reset selectvalue\n    hoveropt = false;\n    options = Object.fromEntries(Object.entries(fixedoptions));\n    optorder = Object.keys(options);\n    selectval = initval;\n  } else if (event.key.length > 1 && !(event.keyCode === 8 || event.keyCode === 46)) {\n    // special key without modification effect (e.g. alt), not backspace/delete\n    return\n  } else if (intext.length > 2 && fetchUrl) {\n    selectval = '';\n    options = await getJSON(`${fetchUrl}?q=${intext}`);\n    fetchedData = Object.assign({}, options);\n    delete(options.ok);\n    optorder = Object.keys(options);\n    typing = true;\n  } else if (!fetchUrl && fixedoptions && intext) {\n    selectval = '';\n    options = Object.fromEntries(Object.entries(fixedoptions).filter(x => x[1].name.toLowerCase().indexOf(intext.toLowerCase()) > -1));\n    const keys = Object.keys(options);\n    optorder = fixedorder.length ? fixedorder.filter(x => keys.indexOf(x.toString()) > -1) : keys;\n    typing = true;\n  } else if (!fetchUrl && fixedoptions) {\n    options = Object.fromEntries(Object.entries(fixedoptions));\n    optorder = fixedorder.length ? fixedorder : Object.keys(options);\n    typing = true;\n  }\n  if (!optorder.length) { hoveropt = false };\n}\n\nfunction starttyping() {\n  const keys = Object.keys(options);\n  optorder = fixedorder.length ? fixedorder : keys;\n  options = fixedorder.length ? fixedoptions : options;\n  typing = true;\n  placeholder = selectval ? niceName(selectval) : '';\n}\n \n</script>\n\n<div class=\"control has-icons-right\" tabindex=\"0\">\n  <input type=\"text\" on:blur={inputdone} class=\"input is-narrow\" placeholder={placeholder} on:keyup|preventDefault|stopPropagation={handleKeyInput} on:focus={starttyping} bind:value={intext}>\n  <span class=\"icon is-right\"><i class=\"fas fa-chevron-down\"></i></span>\n\n  {#if typing}\n  <div class=\"select is-multiple\">\n    <select multiple on:mousedown={e => mouseSelect = true} >\n      {#if !optorder.length}\n      <option disabled>Type more or type less...</option>\n      {/if}\n      {#each optorder as optid} \n      <option selected={optid===hoveropt} value={optid} on:mouseup={e => selectvalue(optid)} on:mousemove={e => hoveropt=optid}>{niceName(options[optid])}</option>\n      {/each}\n  </select>\n  </div>\n  {/if}\n</div>\n","<script>\nimport { onMount } from 'svelte';\nimport { getJSON, postJSON } from './funcJSON.js'\nimport Param from './Param.svelte';\nimport ErrorNotif from './ErrorNotif.svelte';\nimport DynamicSelect from './DynamicSelect.svelte';\nimport { dataset_id, datasetFiles, projsamples } from './stores.js';\n\nexport let errors;\n\nlet preperrors = [];\nlet edited = false;\nlet fetchedSpecies = {};\n\n$: stored = $dataset_id && !edited;\n\n\nfunction editMade() { \n  errors = errors.length ? validate() : [];\n  edited = true; \n}\n\nlet prepdata = {\n  params: [],\n  enzymes: [],\n  no_enzyme: false,\n  quanttype: '',\n  quants: {},\n  labelfree_multisample: true,\n  labelfree_singlesample: {},\n  allspecies: [],\n  species: [],\n  samples: {},\n}\n\nlet selectedspecies;\nlet trysamplenames = '';\nlet labelfree_quant_id;\nlet foundNewSamples = false;\n\n\nfunction niceSpecies(species) { \n  let nice;\n  if (species === undefined) {\n    nice = '';\n  } else if (species.name) {\n    nice = `${species.name}, ${species.linnean}`;\n  } else {\n    nice = `${species.linnean}`;\n  }\n  return nice;\n}\n\nfunction removeOrganism(org_id) {\n  prepdata.species = prepdata.species.filter(x => x.id !== org_id);\n  editMade();\n}\n\nfunction addOrganism() {\n  const species = (selectedspecies in prepdata.allspecies) ? prepdata.allspecies[selectedspecies] : fetchedSpecies[selectedspecies];\n  prepdata.species = [...prepdata.species, species];\n  editMade();\n}\n\n$: isLabelfree = prepdata.quanttype === labelfree_quant_id;\n\nfunction checkSamplesIfNewFiles() {\n  const assocs = Object.values($datasetFiles).map(x => x.associd);\n  prepdata.samples = Object.fromEntries(Object.entries(prepdata.samples).filter(x => assocs.indexOf(Number(x[0])) > -1));\n  for (let associd of assocs.filter(x => !(x in prepdata.samples))) {\n    prepdata.samples[associd] = {model: '', newprojsample: ''};\n  }\n}\n\n$: $datasetFiles ? checkSamplesIfNewFiles() : '';\n\nfunction checkIfNewSamples() {\n  /* checks if ANY sample in current quanttype is a newprojectsample, enabling save button */\n  if (prepdata.quanttype !== labelfree_quant_id) { // Cannot check isLabelfree here, that is slower to update than the call to this func\n    foundNewSamples = prepdata.quants[prepdata.quanttype].chans.some(ch => ch.newprojsample !== '');\n  } else if (!prepdata.labelfree_multisample) {\n    foundNewSamples = prepdata.labelfree_singlesample.newprojsample !== '';\n  } else {\n    foundNewSamples = Object.values(prepdata.samples).some(x => x.newprojsample !== '')\n  }\n}\n\nfunction checkNewSampleLabelfree(associd=false) {\n  /* Checks if entered sample is found in project or if it is a new sample */\n  let sample;\n  if (!prepdata.labelfree_multisample) {\n    sample = prepdata.labelfree_singlesample.newprojsample\n  } else {\n    sample = prepdata.samples[associd].newprojsample;\n  }\n  if (sample == '') { \n    return \n  } else {\n    let uppername = sample.trim().toUpperCase();\n    let found = Object.entries(projsamples).filter(x=>x[1].name.toUpperCase() == uppername).map(x=>x[0])[0]\n    if (found && !prepdata.labelfree_multisample) {\n      prepdata.labelfree_singlesample.model = found;\n      prepdata.labelfree_singlesample.newprojsample = '';\n    } else if (found) {\n      prepdata.samples[associd].model = found;\n      prepdata.samples[associd].newprojsample = '';\n      /* new samples filled in will reset the dropdown ones, do not do this, only on save */\n//    }  else if (prepdata.labelfree_multisample) {\n//      prepdata.samples[associd].model = '';\n//    } else {\n//      prepdata.labelfree_singlesample.model = '';\n    }\n    checkIfNewSamples();\n  }\n}\n\nfunction checkNewSampleIso(chanix) {\n  /* Checks if entered sample is found in project or if it is a new sample */\n  if (prepdata.quants[prepdata.quanttype].chans[chanix].newprojsample == '') { \n    /* at fetchdata, samples are assigned, on:change fires and this is called */\n    return \n  } else {\n    let uppername = prepdata.quants[prepdata.quanttype].chans[chanix].newprojsample.trim().toUpperCase();\n    let found = Object.entries(projsamples).filter(x=>x[1].name.toUpperCase() == uppername).map(x=>x[0])[0]\n    if (found) {\n      prepdata.quants[prepdata.quanttype].chans[chanix].model = found;\n      prepdata.quants[prepdata.quanttype].chans[chanix].newprojsample = '';\n    }\n    checkIfNewSamples();\n  }\n}\n\nfunction parseSampleNames() {\n  /* Parses samples/files/channel combinations pasted in textbox */\n  let ixmap = {};\n  let fnmap = {};\n  if (isLabelfree && !prepdata.labelfree_multisample) {\n    return 0;\n  } else if (isLabelfree) {\n    for (let fn of Object.values($datasetFiles)) {\n      fnmap[fn.name] = fn;\n    }\n  } else {\n    prepdata.quants[prepdata.quanttype].chans.forEach(function(ch, ix) {\n      ixmap[ch.name] = ix;\n    });\n    }\n  for (let line of trysamplenames.trim().split('\\n')) {\n    if (line.indexOf('\\t') > -1) {\n      line = line.trim().split('\\t').map(x => x.trim());\n    } else if (line.indexOf('    ') > -1) {\n      line = line.trim().split('    ').map(x => x.trim());\n    }\n    let nps, ix, aid;\n    if (isLabelfree) {\n      line[0] in fnmap ? (aid = fnmap[line[0]], nps = line[1]) : false;\n      line[1] in fnmap ? (aid = fnmap[line[1]], nps = line[0]) : false;\n      if (aid) {\n        prepdata.samples[aid.associd].newprojsample = nps;\n        checkNewSampleLabelfree(aid.associd);\n      }\n    } else {\n      line[0] in ixmap ? (ix = ixmap[line[0]], nps = line[1]) : false;\n      line[1] in ixmap ? (ix = ixmap[line[1]], nps = line[0]) : false;\n      if (ix > -1) {\n        prepdata.quants[prepdata.quanttype].chans[ix].newprojsample = nps;\n        checkNewSampleIso(ix);\n      }\n    }\n  }\n  editMade();\n}\n\nfunction resetNewSampleName(chan_or_sample) {\n  chan_or_sample.newprojsample = '';\n  checkIfNewSamples();\n  editMade();\n}\n\nasync function doSampleSave(ch_or_samfn, ix) { \n  /* Saves a new sample name to the project on backend */\n  let postdata = {\n    dataset_id: $dataset_id, \n    samplename: ch_or_samfn.newprojsample\n  };\n  let url = '/datasets/save/projsample/';\n  let response;\n  try {\n    response = await postJSON(url, postdata);\n  } catch(error) {\n    if (error.message === '404') {\n      preperrors = [preperrors, 'Save dataset before saving new samples'];\n    }\n    return;\n  }\n  // just add the latest projsample, do not just assign the whole projsamples dict, async problems!\n  projsamples[response.psid] = {name: response.psname, id: response.psid};\n  return [response.psid, ix];\n}\n\nasync function saveNewSamples() {\n  /* Goes through each of the new sample names and */\n  let saves = [];\n  if (!isLabelfree) {\n    prepdata.quants[prepdata.quanttype].chans.map(function(ch, ix) { return [ix, ch]}).filter(ch => ch[1].newprojsample).forEach(function(ch) {\n      saves.push(doSampleSave(ch[1], ch[0]));\n    }); \n    for (let item of saves) {\n      let [psid, ix] = await item;\n      prepdata.quants[prepdata.quanttype].chans[ix].newprojsample = '';\n      prepdata.quants[prepdata.quanttype].chans[ix].model = psid;\n    }\n  } else if (!prepdata.labelfree_multisample && foundNewSamples) {\n    const savedsample = await doSampleSave(prepdata.labelfree_singlesample);\n    prepdata.labelfree_singlesample.model = savedsample[0];\n    prepdata.labelfree_singlesample.newprojsample = '';\n  } else {\n    Object.entries(prepdata.samples).filter(x => x[1].newprojsample).forEach(function(samfn) {\n      saves.push(doSampleSave(samfn[1], samfn[0]));\n    });\n    for (let item of saves) {\n      let [psid, associd] = await item;\n      prepdata.samples[associd].newprojsample = '';\n      prepdata.samples[associd].model = psid;\n    }\n  }\n  checkIfNewSamples();\n}\n\nexport function validate() {\n  let comperrors = [];\n\tif (!prepdata.no_enzyme && !prepdata.enzymes.filter.length) {\n\t\tcomperrors.push('Enzyme selection is required');\n\t}\n\tif (!prepdata.quanttype) {\n\t\tcomperrors.push('Quant type selection is required');\n\t}\n  if (isLabelfree && prepdata.labelfree_multisample) {\n\t\tfor (let fn of Object.values($datasetFiles)) {\n\t\t\tif (!prepdata.samples[fn.associd].model && !prepdata.samples[fn.associd].newprojsample) {\n\t\t\t\tcomperrors.push('Labelfree requires sample name for each file');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\t\n  } else if (isLabelfree) {\n    if (prepdata.labelfree_singlesample.model === '') {\n      comperrors.push('Labelfree singlesample requires a sample name');\n    }\n\t} else if (prepdata.quanttype in prepdata.quants) {\n\t\tfor (let ch of prepdata.quants[prepdata.quanttype].chans) {\n\t\t\tif (ch.model === '') { \n\t\t\t\tcomperrors.push('Sample name for each channel is required');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n  for (let param of Object.values(prepdata.params).filter(p => p.inputtype !== 'checkbox')) {\n    if (param.model === undefined || param.model === '') {\n\t\t\tcomperrors.push(param.title + ' is required');\n\t\t}\n\t}\n  for (let param of Object.values(prepdata.params).filter(p => p.inputtype === 'checkbox')) {\n    if (!param.fields.some(f => f.checked)) {\n\t\t\tcomperrors.push(param.title + ' is required');\n\t\t}\n\t}\n\tif (!Object.keys(prepdata.species).length) {\n\t\tcomperrors.push('Organism(s) is/are required');\n\t}\n  return comperrors;\n}\n\nexport async function save() {\n  errors = validate();\n  if (!Object.keys($datasetFiles).length && isLabelfree) {\n    preperrors = [...preperrors, 'Add files before saving data'];\n  }\n  if (!$dataset_id) {\n    preperrors = [...preperrors, 'Save dataset before saving sample prep'];\n  }\n  if (errors.length === 0 && preperrors.length === 0) { \n    let postdata = {\n      dataset_id: $dataset_id,\n      enzymes: prepdata.no_enzyme ? [] : prepdata.enzymes,\n      params: prepdata.params,\n      quanttype: prepdata.quanttype,\n      labelfree: isLabelfree,\n      species: prepdata.species,\n    };\n    if (!isLabelfree) {\n      postdata.samples = prepdata.quants[prepdata.quanttype].chans;\n    } else if (prepdata.labelfree_multisample) {\n      postdata.filenames = Object.values($datasetFiles);\n      postdata.samples = prepdata.samples;\n    } else {\n      postdata.filenames = Object.values($datasetFiles);\n      postdata.samples = Object.fromEntries(postdata.filenames.map(fn => [fn.associd, prepdata.labelfree_singlesample]));\n    }\n    let url = '/datasets/save/sampleprep/';\n    await postJSON(url, postdata);\n    fetchData();\n  }\n}\n\nasync function fetchData() {\n  let url = '/datasets/show/sampleprep/';\n  url = $dataset_id ? url + $dataset_id : url;\n\tconst response = await getJSON(url);\n  for (let [key, val] of Object.entries(response)) { prepdata[key] = val; }\n  labelfree_quant_id = Object.entries(prepdata.quants).filter(x => x[1].name === 'labelfree').map(x=>Number(x[0])).pop();\n  edited = false;\n}\n\nonMount(async() => {\n  await fetchData();\n})\n\n</script>\n\n\n<h5 id=\"sampleprep\" class=\"has-text-primary title is-5\">\n  {#if stored}\n  <i class=\"icon fas fa-check-circle\"></i>\n  {:else if edited}\n  <i class=\"icon fas fa-edit\"></i>\n  {/if}\n  Sample prep\n  <button class=\"button is-small is-danger has-text-weight-bold\" disabled={!edited} on:click={save}>Save</button>\n  <button class=\"button is-small is-info has-text-weight-bold\" disabled={!edited} on:click={fetchData}>Revert</button>\n</h5>\n\n<ErrorNotif errors={preperrors} />\n\n<div class=\"field\">\n  <label class=\"label\">Organism</label>\n  <DynamicSelect intext=\"Type to get more organisms\" fixedoptions={prepdata.allspecies} fixedorder={Object.values(prepdata.allspecies).sort((a,b) => b.total - a.total).map(x => x.id)} bind:selectval={selectedspecies} fetchUrl=\"/datasets/show/species/\" bind:fetchedData={fetchedSpecies} niceName={niceSpecies} on:selectedvalue={addOrganism} />\n</div>\n<div class=\"tags\">\n  {#each prepdata.species as spec}\n  <span class=\"tag is-medium is-info\">\n    {niceSpecies(spec)}\n    <button class=\"delete is-small\" on:click={e => removeOrganism(spec.id)}></button>\n  </span>\n{/each}\n</div>\n\n<div class=\"field\">\n  <label class=\"label\">Enzymes</label>\n  <input type=\"checkbox\" on:change={editMade} bind:checked={prepdata.no_enzyme}>No enzyme\n  {#if !prepdata.no_enzyme}\n  {#each prepdata.enzymes as enzyme}\n  <div class=\"control\">\n    <input on:change={editMade} bind:checked={enzyme.checked} type=\"checkbox\">{enzyme.name}\n  </div>\n  {/each}\n  {/if}\n</div>\n\n{#each Object.entries(prepdata.params) as [param_id, param]}\n<Param bind:param={param} on:edited={editMade} />\n{/each}\n\n\n<div class=\"field\">\n  <label class=\"label\">Quant type</label>\n  <div class=\"control\">\n    <div class=\"select\">\n      <select on:change={checkIfNewSamples} bind:value={prepdata.quanttype}>\n        <option disabled value=\"\">Please select one</option>\n        {#each Object.values(prepdata.quants) as quant}\n        <option value={quant.id}>{quant.name}</option>\n        {/each}\n      </select>\n    </div>\n  </div>\n</div>\n\n{#if prepdata.quanttype}\n<div class=\"field\">\n  <label class=\"label\">Samples</label>\n  <textarea class=\"textarea\" bind:value={trysamplenames} placeholder=\"Paste your sample names here (one line per sample, tab separated sample/file or channel)\"></textarea>\n  <a class=\"button is-primary\" on:click={parseSampleNames}>Parse sample names</a>\n  <div class=\"control\">\n    {#if isLabelfree}\n    <div id=\"labelfree_samples\">\n      <input type=\"checkbox\" on:change={checkIfNewSamples} bind:checked={prepdata.labelfree_multisample}>One sample per file?\n    </div>\n    {/if}\n  </div>\n</div>\n<table class=\"table is-fullwidth\" >\n  <thead>\n    <tr>\n      {#if isLabelfree && prepdata.labelfree_multisample}\n      <th>Filename</th>\n      {:else if !isLabelfree}\n      <th>Channel</th>\n      {/if} \n      <th colspan=\"2\">Sample name \n        {#if foundNewSamples}\n        <a class=\"button is-danger is-small is-pulled-right\" on:click={saveNewSamples}>Save new samples</a>\n        {:else}\n        <a class=\"button is-danger is-small is-pulled-right\" disabled>Save new samples</a>\n        {/if}\n      </th>\n    </tr>\n  </thead>\n  <tbody>\n    {#if !isLabelfree}\n    {#each prepdata.quants[prepdata.quanttype].chans as channel, chix}\n    <tr>\n      <td>{channel.name}</td>\n      <td>\n        <div class=\"select\">\n          <select bind:value={channel.model} on:change={e => resetNewSampleName(channel)}>\n            <option disabled value=\"\">Pick a project-sample</option>\n            {#each Object.entries(projsamples) as [s_id, sample]}\n            <option value={s_id}>{sample.name}</option>\n            {/each}\n          </select>\n        </div>\n      </td>\n      <td>\n        <p class={channel.newprojsample && foundNewSamples ? 'control has-icons-left' : 'control'}>\n        <input bind:value={channel.newprojsample} class=\"input is-normal\" on:change={e => checkNewSampleIso(chix)} placeholder=\"or define a new sample\">\n        {#if foundNewSamples && channel.newprojsample}\n        <span class=\"icon is-left has-text-danger\">\n          <i class=\"fas fa-asterisk\"></i>\n        </span>\n        {/if}\n        </p>\n      </td>\n    </tr>\n    {/each}\n    {:else if isLabelfree && prepdata.labelfree_multisample}\n    {#each Object.values($datasetFiles) as file}\n    {#if file.associd in prepdata.samples }\n    <tr>\n      <td>{file.name}</td>\n      <td>\n        <div class=\"select\">\n          <select bind:value={prepdata.samples[file.associd].model} on:change={e => resetNewSampleName(prepdata.samples[file.associd])}> \n            <option disabled value=\"\">Pick a project-sample</option>\n            {#each Object.entries(projsamples) as [s_id, sample]}\n            <option value={s_id}>{sample.name}</option>\n            {/each}\n          </select>\n        </div>\n      </td>\n      <td><input bind:value={prepdata.samples[file.associd].newprojsample} on:change={e => checkNewSampleLabelfree(file.associd)} placeholder=\"or define a new sample\" class=\"input is-normal\"></td> \n    </tr>\n    {/if}\n    {/each}\n    {:else if isLabelfree && Object.keys($datasetFiles).length}\n    <tr><td>\n        <div class=\"select\">\n          <select bind:value={prepdata.labelfree_singlesample.model} on:change={e => resetNewSampleName(prepdata.labelfree_singlesample)}>\n            <option disabled value=\"\">Pick a project-sample</option>\n            {#each Object.entries(projsamples) as [s_id, sample]}\n            <option value={s_id}>{sample.name}</option>\n            {/each}\n          </select>\n        </div>\n      </td>\n      <td><input bind:value={prepdata.labelfree_singlesample.newprojsample} on:change={e => checkNewSampleLabelfree(prepdata.labelfree_singlesample)} placeholder=\"or define a new sample\" class=\"input is-normal\"></td>\n    </tr>\n\n    {/if}\n  </tbody>\n</table>\n{/if}\n","<script>\n\nimport { createEventDispatcher } from 'svelte';\nconst dispatch = createEventDispatcher();\n\n// props\nexport let dsinfo;\nexport let hirief_ranges;\nexport let prefracs;\n\nlet errors = [];\n\n\n$: hiriefselected = prefracs.some(pf => pf.id == dsinfo.prefrac_id && pf.name.toLowerCase().indexOf('hirief') > -1)\n\nfunction editMade() {\n  dispatch('edited');\n}\n\nexport function validate() {\n  errors = [];\n\tif (hiriefselected && !dsinfo.hiriefrange) {\n\t\terrors.push('HiRIEF range is required');\n\t}\n\telse if (!hiriefselected && dsinfo.prefrac_id && !dsinfo.prefrac_length) {\n\t\terrors.push('Prefractionation length is required');\n\t}\n\tif (dsinfo.prefrac_id && !dsinfo.prefrac_amount) {\n\t\terrors.push('Prefractionation fraction amount is required');\n\t}\n  return errors;\n}\n\nfunction save() {\n  if (!validate) { return }\n\n}\n\n</script>\n\n<div class=\"field\">\n  <label class=\"label\">Prefractionation</label>\n  <div class=\"control\">\n    <div class=\"select\">\n      <select on:change={editMade} bind:value={dsinfo.prefrac_id}>\n        <option value=\"\">None</option>\n        {#each prefracs as prefrac}\n        <option value={prefrac.id}>{prefrac.name}</option>\n        {/each}\n      </select>\n    </div>\n  </div>\n</div>\n\n{#if hiriefselected}\n<div class=\"field\"> \n  <label class=\"label\">HiRIEF range</label>\n  <div class=\"control\">\n    <div class=\"select\">\n      <select on:change={editMade} bind:value={dsinfo.hiriefrange}>\n        <option disabled value=\"\">Please select one</option>\n        {#each hirief_ranges as range}\n        <option value={range.id}>{range.name}</option>\n        {/each}\n      </select>\n    </div>\n  </div>\n</div>\n{:else if dsinfo.prefrac_id}\n<div class=\"field\">\n  <label class=\"label\">Prefractionation length</label>\n  <div class=\"control\">\n    <input type=\"number\" class=\"input\" placeholder=\"in minutes\" on:change={editMade} bind:value={dsinfo.prefrac_length}>\n  </div>\n</div>\n{/if}\n{#if dsinfo.prefrac_id}\n<div class=\"field\">\n  <label class=\"label\">Number of fractions</label>\n  <div class=\"control\">\n    <input type=\"number\" class=\"input\" placeholder=\"How many fractions of prefractionation\" on:change={editMade} bind:value={dsinfo.prefrac_amount}>\n  </div>\n</div>\n{/if}\n","<script>\nimport { onMount } from 'svelte';\nimport { getJSON, postJSON } from './funcJSON.js'\nimport { dataset_id, datasetFiles, projsamples } from './stores.js';\nimport ErrorNotif from './ErrorNotif.svelte';\nimport DynamicSelect from './DynamicSelect.svelte';\n\nexport let errors;\n\nlet lcerrors = [];\nlet channelError = {};\n\nlet lcdata = {\n  quants: {},\n  quanttype: '',\n  samples: {},\n}\nlet edited = false;\n\n$: Object.keys($datasetFiles).length ? fetchData() : false;\n\n$: foundNewSamples = Object.values(lcdata.samples).some(x => x.newprojsample !== '');\n$: stored = $dataset_id && !edited;\n\n\nfunction editMade() {\n  edited = true;\n}\n\nfunction okChannel(fid) {\n  lcdata.samples[fid].badChannel = false;\n  editMade();\n}\n\nfunction badChannel(fid) {\n  console.log('bad ch');\n  console.log(fid);\n  lcdata.samples[fid].badChannel = true;\n}\n\n\nasync function doSampleSave(ch_or_samfn, ix) { \n  /* Saves a new sample name to the project on backend */\n  let postdata = {\n    dataset_id: $dataset_id, \n    samplename: ch_or_samfn.newprojsample\n  };\n  let url = '/datasets/save/projsample/';\n  const response = await postJSON(url, postdata);\n  // just add the latest projsample, do not just assign the whole projsamples dict, async problems!\n  projsamples[response.psid] = response.psname;\n  return [response.psid, ix];\n}\n\nasync function saveNewSamples() {\n  /* Goes through each of the new sample names and */\n  let saves = [];\n  Object.entries(lcdata.samples).filter(x => x[1].newprojsample).forEach(function(samfn) {\n    saves.push(doSampleSave(samfn[1], samfn[0]));\n  });\n  for (let item of saves) {\n    let [psid, associd] = await item;\n    lcdata.samples[associd].newprojsample = '';\n    lcdata.samples[associd].sample = psid;\n  }\n}\n\nfunction checkNewSample(file) {\n  /* Checks if entered sample is found in project or if it is a new sample */\n  let uppername = lcdata.samples[file.associd].newprojsample.trim().toUpperCase();\n  let found = Object.entries(projsamples).filter(x=>x[1].name.toUpperCase() == uppername).map(x=>x[0])[0]\n  if (found) {\n    lcdata.samples[file.associd].sample = parseInt(found);\n    lcdata.samples[file.associd].newprojsample = '';\n  }\n  editMade();\n}\n\nfunction validate() {\n  let comperrors = [];\n\tif (!lcdata.quanttype) {\n\t\tcomperrors.push('Quant type selection is required');\n\t}\n  for (let fn of Object.values($datasetFiles)) {\n    if (!lcdata.samples[fn.associd].sample) {\n      comperrors.push('Sample name for each file/channel is required');\n    }\n    if (!lcdata.samples[fn.associd].channel) {\n      comperrors.push('Channel for each file/sample is required');\n    }\n  }\t\n  return comperrors;\n}\n\nasync function save() {\n  errors = validate();\n  if (!Object.keys($datasetFiles).length) {\n    lcerrors = [...lcerrors, 'Add files before saving data'];\n  }\n  if (errors.length === 0) { \n    let postdata = {\n      dataset_id: $dataset_id,\n      quanttype: lcdata.quanttype,\n      samples: lcdata.samples,\n      filenames: Object.values($datasetFiles),\n    }\n    console.log(postdata);\n    const url = '/datasets/save/labelcheck/';\n    const response = await postJSON(url, postdata);\n    fetchData();\n  }\n}\n\nasync function fetchData() {\n  let url = '/datasets/show/labelcheck/';\n  url = $dataset_id ? url + $dataset_id : url;\n\tconst response = await getJSON(url);\n  for (let [key, val] of Object.entries(response)) { lcdata[key] = val; }\n  edited = false;\n}\n\nonMount(async() => {\n  await fetchData();\n})\n</script>\n\n\n<h5 id=\"labelcheck\" class=\"has-text-primary title is-5\">\n  {#if stored}\n  <i class=\"icon fas fa-check-circle\"></i>\n  {:else if edited}\n  <i class=\"icon fas fa-edit\"></i>\n  {/if}\n  Label check\n  <button class=\"button is-small is-danger has-text-weight-bold\" disabled={!edited} on:click={save}>Save</button>\n  <button class=\"button is-small is-info has-text-weight-bold\" disabled={!edited} on:click={fetchData}>Revert</button>\n</h5>\n\n<ErrorNotif errors={lcerrors} />\n\n<div class=\"field\">\n  <label class=\"label\">Quant type</label>\n  <div class=\"control\">\n    <div class=\"select\">\n      <select on:change={editMade} bind:value={lcdata.quanttype}>\n        <option disabled value=\"\">Please select one</option>\n        {#each Object.values(lcdata.quants) as quant}\n        <option value={quant.id}>{quant.name}</option>\n        {/each}\n      </select>\n    </div>\n  </div>\n</div>\n\n{#if foundNewSamples}\n<a class=\"button is-danger is-small is-pulled-right\" on:click={saveNewSamples}>Save new samples</a>\n{:else}\n<a class=\"button is-danger is-small is-pulled-right\" disabled>Save new samples</a>\n{/if}\n\n<table class=\"table is-fullwidth\" >\n  <thead>\n    <tr>\n      <th>Sample</th>\n      <th>Channel</th>\n    </tr>\n  </thead>\n  {#if Object.keys(lcdata.samples).length}\n  <tbody>\n    {#each Object.values($datasetFiles) as file}\n    {#if file.associd in lcdata.samples}\n    <tr>\n      <td>\n        <label class=\"label\">\n          {#if lcdata.samples[file.associd].newprojsample}\n          <span class=\"icon has-text-danger\"><i class=\"fas fa-asterisk\"></i></span>\n          {/if}\n          {file.name}\n        </label>\n        <div class=\"field\">\n          <DynamicSelect bind:intext={lcdata.samples[file.associd].samplename} fixedoptions={projsamples} bind:unknowninput={lcdata.samples[file.associd].newprojsample} bind:selectval={lcdata.samples[file.associd].sample} on:selectedvalue={editMade} on:newvalue={e => checkNewSample(file)} niceName={x => x.name}/>\n        </div>\n      </td>\n      <td>\n        <div class=\"field\">\n          <div class=\"control\">\n            <p class={lcdata.samples[file.associd].badChannel ? 'control has-icons-left': ''}>\n            {#if lcdata.quanttype}\n            <DynamicSelect bind:intext={lcdata.samples[file.associd].channelname} niceName={x=>x.name} bind:fixedoptions={lcdata.quants[lcdata.quanttype].chans} bind:fixedorder={lcdata.quants[lcdata.quanttype].chanorder} bind:selectval={lcdata.samples[file.associd].channel} on:selectedvalue={e => okChannel(file.associd)} on:illegalvalue={e => badChannel(file.associd)} />\n\n            {#if lcdata.samples[file.associd].badChannel}\n        <span class=\"icon is-left has-text-danger\">\n          <i class=\"fas fa-asterisk\"></i>\n        </span>\n            {/if}\n            {/if}\n            </p>\n          </div>\n        </div>\n      </td>\n    </tr>\n    {/if}\n    {/each}\n  </tbody>\n  {/if}\n</table>\n","<script>\nimport { onMount } from 'svelte';\nimport { getJSON, postJSON } from './funcJSON.js'\nimport ErrorNotif from './ErrorNotif.svelte';\nimport { dataset_id } from './stores.js';\n\nexport let errors;\n\nlet preperrors = [];\nlet edited = false;\n\n$: stored = $dataset_id && !edited;\n\n\nfunction editMade() { \n  errors = errors.length ? validate() : [];\n  edited = true; \n}\n\nlet prepdata = {\n  quanttype: '',\n  quants: {},\n}\n\nexport function validate() {\n  let comperrors = [];\n\tif (!prepdata.quanttype) {\n\t\tcomperrors.push('Quant type selection is required');\n\t}\n  return comperrors;\n}\n\nexport async function save() {\n  errors = validate();\n  if (!$dataset_id) {\n    preperrors = [...preperrors, 'Save dataset before saving sample prep'];\n  }\n  if (errors.length === 0 && preperrors.length === 0) { \n    let postdata = {\n      dataset_id: $dataset_id,\n      quanttype: prepdata.quanttype,\n    };\n    let url = '/datasets/save/pooledlc/';\n    await postJSON(url, postdata);\n    fetchData();\n  }\n}\n\nasync function fetchData() {\n  let url = '/datasets/show/pooledlc/';\n  url = $dataset_id ? url + $dataset_id : url;\n\tconst response = await getJSON(url);\n  for (let [key, val] of Object.entries(response)) { prepdata[key] = val; }\n  edited = false;\n}\n\nonMount(async() => {\n  await fetchData();\n})\n\n</script>\n\n\n<h5 id=\"sampleprep\" class=\"has-text-primary title is-5\">\n  {#if stored}\n  <i class=\"icon fas fa-check-circle\"></i>\n  {:else if edited}\n  <i class=\"icon fas fa-edit\"></i>\n  {/if}\n  Sample prep\n  <button class=\"button is-small is-danger has-text-weight-bold\" disabled={!edited} on:click={save}>Save</button>\n  <button class=\"button is-small is-info has-text-weight-bold\" disabled={!edited} on:click={fetchData}>Revert</button>\n</h5>\n\n<ErrorNotif errors={preperrors} />\n\n<div class=\"field\">\n  <label class=\"label\">Quant type</label>\n  <div class=\"control\">\n    <div class=\"select\">\n      <select on:change={editMade} bind:value={prepdata.quanttype}>\n        <option disabled value=\"\">Please select one</option>\n        {#each Object.values(prepdata.quants) as quant}\n        <option value={quant.id}>{quant.name}</option>\n        {/each}\n      </select>\n    </div>\n  </div>\n</div>\n","<script>\n\nimport { onMount } from 'svelte';\nimport { getJSON, postJSON } from './funcJSON.js'\nimport { dataset_id, datasetFiles } from './stores.js';\n\nlet files = {\n  newFiles: {},\n  dsfn_order: [],\n  newfn_order: [],\n};\nlet addedFiles = {};\nlet removed_files = {};\nlet findQuery = '';\nlet allDsSelector = false;\nlet allNewSelector = false;\nlet sortkey = 'date';\nlet sortascending = {\n  'date': true,\n  'name': true,\n  'size': true,\n  'instrument': true,\n}\n\nlet ok_files = [];\nlet outside_files = [];\n$: ok_files = Object.values(addedFiles).concat(files.dsfn_order.map(x => $datasetFiles[x])).sort((a, b) => a[sortkey] > b[sortkey] === sortascending[sortkey])\n  ;\n$: outside_files = Object.values(removed_files).concat(files.newfn_order.map(x => files.newFiles[x])).sort((a, b) => a[sortkey] > b[sortkey] === sortascending[sortkey]);\n\n\nfunction reSort(key) {\n  if (sortkey === key) {\n    sortascending[key] = sortascending[key] === false;\n  } else {\n    sortkey = key;\n  }\n}\n\n\nasync function findFiles(event) {\n  if (event.keyCode === 13) {\n    const response = await getJSON(`/datasets/find/files?q=${findQuery.split(' ').join(',')}`);\n    for (let [key, val] of Object.entries(response)) { files[key] = val; }\n  }\n}\n\nfunction isoTime(timestamp) {\n  let x = new Date(timestamp);\n  return x.toISOString();\n}\n\nfunction selectAllNew() {\n  let select_state = allNewSelector === false;\n  for (let fnid in files.newFiles) {\n    files.newFiles[fnid].checked = select_state;\n  }\n}\n\n$: changed = Object.keys(addedFiles).length || Object.keys(removed_files).length;\n$: selectedFiles = Object.values(files.newFiles).concat(Object.values(removed_files)).filter(fn => fn.checked);\n\nfunction deleteFile(fnid) {\n  if (fnid in $datasetFiles) {\n    removed_files[fnid] = $datasetFiles[fnid]\n    files.dsfn_order = files.dsfn_order.filter(x => x !== fnid);\n  } else if (fnid in addedFiles) {\n    addedFiles = Object.fromEntries(Object.entries(addedFiles).filter(x => x[1].id !== fnid));\n  }\n}\n\nfunction addFiles() {\n  for (let fn of Object.values(removed_files).filter(fn => fn.checked)) {\n    fn.checked = false;\n    //removed_files = file.removed_files.filter[fn.id] = fn;\n    delete(removed_files[fn.id]);\n    files.dsfn_order = [fn.id].concat(files.dsfn_order);\n    //files.newfn_order = files.newfn_order.filter(fnid => fnid !== fn.id);\n  }\n  for (let fn of Object.values(files.newFiles).filter(fn => fn.checked)) {\n    fn.checked = false;\n    addedFiles[fn.id] = fn;\n    files.newfn_order = files.newfn_order.filter(fnid => fnid !== fn.id);\n    //delete(files.newFiles[fn.id]);\n  }\n}\n\nasync function save() {\n  let url = '/datasets/save/files/';\n  let postdata = {\n    dataset_id: $dataset_id,\n    added_files: addedFiles,\n    removed_files: removed_files,\n  };\n  await postJSON(url, postdata);\n  fetchFiles();\n}\n\nasync function fetchFiles() {\n  let url = '/datasets/show/files/';\n  url = $dataset_id ? url + $dataset_id : url;\n  console.log(url);\n\tconst response = await getJSON(url);\n  for (let [key, val] of Object.entries(response)) { files[key] = val; }\n  for (let key in $datasetFiles) { delete($datasetFiles[key]); }\n  for (let [key, val] of Object.entries(response.datasetFiles)) { $datasetFiles[key] = val; }\n  addedFiles = {};\n  removed_files = {};\n}\n\nonMount(async() => {\n  fetchFiles();\n});\n\n</script>\n\n<div class=\"content is-small\">\n  <input class=\"input is-small\" on:keyup={findFiles} bind:value={findQuery} type=\"text\" placeholder=\"Type a query and press enter to find analyses\">\n  <div>Showing {files.newfn_order.length} new files ({selectedFiles.length} selected), {files.dsfn_order.length} files in dataset (incl. {Object.keys(removed_files).length}, excl. {Object.keys(addedFiles).length} added files)</div>\n  <div>\n    <button on:click={save} class=\"button is-danger is-small\" disabled={!changed}>Save</button>\n    <button on:click={fetchFiles} class=\"button is-info is-small\">Revert</button>\n    <button on:click={addFiles} class=\"button is-small\" disabled={!selectedFiles.length} >Add selected files</button>\n  </div>\n  <table class=\"table\">\n    <thead>\n      <tr>\n        <th><input type=\"checkbox\" bind:checked={allNewSelector} on:click={selectAllNew}></th>\n        <th></th>\n        <th>\n          File <span on:click={e => reSort('name')} class=\"icon is-small\"><i class=\"fas fa-sort\"></i></span>\n        </th>\n        <th>\n          Date <span on:click={e => reSort('date')} class=\"icon is-small\"><i class=\"fas fa-sort\"></i></span>\n        </th>\n        <th>\n          Size <span on:click={e => reSort('size')} class=\"icon is-small\"><i class=\"fas fa-sort\"></i></span>\n        </th>\n        <th>\n          Instrument <span on:click={e => reSort('instrument')} class=\"icon is-small\"><i class=\"fas fa-sort\"></i></span>\n        </th>\n      </tr>\n    </thead> \n    <tbody>\n      \n      {#each ok_files as fn}\n      <tr>\n        <td><span on:click={e => deleteFile(fn.id)} class=\"icon is-small has-text-danger\"><i class=\"fas fa-times\"></i></span></td>\n        <td>\n          {#if fn.id in $datasetFiles}\n          <span class=\"icon is-small has-text-primary\"><i class=\"fas fa-database\"></i></span>\n          {/if}\n        </td>\n        <td>{fn.name}</td>\n        <td>{isoTime(fn.date)}</td>\n        <td>{fn.size}MB</td>\n        <td>{fn.instrument}</td>\n      </tr>\n      {/each}\n      {#each outside_files as fn}\n      <tr>\n        <td>\n          <input type=\"checkbox\" bind:checked={fn.checked}>\n        </td>\n        <td></td>\n        <td>{fn.name}</td>\n        <td>{isoTime(fn.date)}</td>\n        <td>{fn.size}MB</td>\n        <td>{fn.instrument}</td>\n      </tr>\n      {/each}\n    </tbody>\n  </table>\n</div>\n","<script>\nimport { getJSON, postJSON } from './funcJSON.js'\nimport { dataset_id, datatype_id, datasetFiles, projsamples } from './stores.js';\nimport { onMount } from 'svelte';\nimport Acquicomp from './Acquicomp.svelte';\nimport Prepcomp from './Prepcomp.svelte';\nimport Msdata from './Msdata.svelte';\nimport LCheck from './LCheck.svelte';\nimport PooledLCheck from './PooledLCheck.svelte';\nimport Files from './Files.svelte';\nimport ErrorNotif from './ErrorNotif.svelte';\nimport DynamicSelect from './DynamicSelect.svelte';\n  \n// FIXME dataset_id is global on django template and not updated on save, change that!, FIXED???\n// FIXME files do not get updated\nif (init_dataset_id) { dataset_id.set(init_dataset_id) };\n\n\nlet mssubcomp;\nlet acquicomp;\nlet prepcomp;\nlet lccomp;\nlet pooledlc;\nlet filescomp;\nlet edited = false;\nlet errors = {\n  basics: [],\n  sprep: [],\n  acqui: [],\n  lc: [],\n};\nlet saveerrors = Object.assign({}, errors);\nlet comperrors = [];\n\n\nlet dsinfo = {\n  datatype_id: '',\n  old_project_id: '',\n  project_id: '',\n  project_name: '',\n  ptype_id: '',\n  storage_location: '',\n  oldnewprojectname: '',\n  newprojectname: '',\n  experiment_id: '',\n  runname: '',\n  pi_id: '',\n  newpiname: '',\n  pi_name: '',\n  externalcontactmail: '',\n  prefrac_id: '',\n  prefrac_length: '',\n  prefrac_amount: '',\n  hiriefrange: '',\n}\n\nlet pdata = {\n  datasettypes: [],\n  ptypes: [],\n  projects: {},\n  local_ptype_id: '',\n  external_pis: [],\n  prefracs: [],\n  hirief_ranges: [],\n}\n\nlet components = [];\nlet isNewProject = false;\nlet isNewExperiment = false;\nlet isNewPI = false;\nlet experiments = []\nlet stored = true;\nlet tabshow = 'meta';\nlet tabcolor = 'has-text-grey-lighter';\n  // Yes, for microscopy/genomics, we need separation between samples/prep\n  // files is given, and possibly samples as well, check it out but samples is needed for:\n  // - QMS, LCheck, IP, TPP, microscopy QC?, genomics\n\n$: showMsdata = components.indexOf('acquisition') > -1;\n$: isExternal = dsinfo.ptype_id && dsinfo.ptype_id !== pdata.local_ptype_id;\n$: isLabelcheck = pdata.datasettypes.filter(x => x.id === dsinfo.datatype_id).filter(x => x.name.indexOf('abelcheck') > -1).length;\n\nasync function getcomponents() {\n  const result = await getJSON(`/datasets/show/components/${dsinfo.datatype_id}`);\n  components = result.components;\n}\n\nfunction switchDatatype() {\n  getcomponents();\n  editMade();\n}\n\nasync function project_selected(saved=false) {\n  // Gets experiments, project details when selecting a project\n  if (dsinfo.project_id) {\n    const result = await getJSON(`/datasets/show/project/${dsinfo.project_id}`);\n    dsinfo.pi_name = pdata.external_pis[result.pi_id].name;\n    dsinfo.ptype_id = result.ptype_id;\n    experiments = result.experiments;\n    for (let key in projsamples) { delete(projsamples[key]);};\n    for (let [key, val] of Object.entries(result.projsamples)) { projsamples[key] = val; }\n    isNewProject = false;\n  }\n  if (!saved) {\n    dsinfo.experiment_id = '';\n  }\n  editMade();\n}\n\nfunction setNewProj() {\n  isNewProject = true;\n  dsinfo.ptype_id = '';\n  dsinfo.externalcontactmail = '';\n  experiments = [];\n  for (let key in projsamples) { delete(projsamples[key]);};\n\n  editMade();\n}\n\nfunction editMade() {\n  edited = true;\n  errors.basics = errors.basics.length ? validate() : [];\n}\n\nasync function fetchDataset() {\n  let url = '/datasets/show/info/';\n  url = $dataset_id ? url + $dataset_id : url;\n\tconst response = await getJSON(url);\n  for (let [key, val] of Object.entries(response.projdata)) { pdata[key] = val; }\n  for (let [key, val] of Object.entries(response.dsinfo)) { dsinfo[key] = val; }\n  if ($dataset_id) {\n    getcomponents();\n    await project_selected(true); // true is saved param\n    isNewExperiment = false;\n  }\n  edited = false;\n}\n\nfunction validate() {\n\tcomperrors = [];\n\tconst re = RegExp('^[a-z0-9-_]+$', 'i');\n\tif ((isNewProject && !dsinfo.newprojectname) || (!isNewProject && !dsinfo.project_id)) {\n\t\tcomperrors.push('Project needs to be selected or created');\n\t}\n\telse if (isNewProject && dsinfo.newprojectname && !re.test(dsinfo.newprojectname)) {\n\t\tcomperrors.push('Project name may only contain a-z 0-9 - _');\n\t}\n  if (!dsinfo.ptype_id) {\n    comperrors.push('Project type selection is required');\n  }\n\tif (!dsinfo.runname) {\n\t\tcomperrors.push('Run name is required');\n\t}\n\telse if (!re.test(dsinfo.runname)) {\n\t\tcomperrors.push('Run name may only contain a-z 0-9 - _');\n\t}\n  if (showMsdata && ((isNewExperiment && !dsinfo.newexperimentname) || (!isNewExperiment && !dsinfo.experiment_id))) {\n\t\tcomperrors.push('Experiment is required');\n\t}\n\telse if (showMsdata && isNewExperiment && dsinfo.newexperimentname && !re.test(dsinfo.newexperimentname)) {\n\t\tcomperrors.push('Experiment name may only contain a-z 0-9 - _');\n\t}\n  if (isExternal) {\n\t\tif (isNewProject && !dsinfo.newpiname && (!dsinfo.pi_id || dsinfo.pi_id === pdata.internal_pi_id)) {\n\t\t\tcomperrors.push('Need to select or create a PI');\n\t\t}\n\t\tif (!dsinfo.externalcontactmail) {\n\t\t\tcomperrors.push('External contact is required');\n\t\t}\n\t}\n  // This is probably not possible to save in UI, button is disabled\n\tif (!dsinfo.datatype_id) {\n\t\tcomperrors.push('Datatype is required');\n\t}\n  return comperrors;\n}\n\nasync function save() {\n  errors.basics = validate();\n  if (showMsdata) { \n    let mserrors = mssubcomp.validate();\n    errors.basics = [...errors.basics, ...mserrors];\n  }\n  if (errors.basics.length === 0) { \n    let postdata = {\n      dataset_id: $dataset_id,\n      ptype_id: dsinfo.ptype_id,\n      datatype_id: dsinfo.datatype_id,\n      runname: dsinfo.runname,\n      prefrac_id: dsinfo.prefrac_id,\n      prefrac_length: dsinfo.prefrac_length,\n      prefrac_amount: dsinfo.prefrac_amount,\n      hiriefrange: dsinfo.hiriefrange,\n    };\n    if (isNewProject) {\n      postdata.newprojectname = dsinfo.newprojectname;\n    } else {\n      postdata.project_id = dsinfo.project_id;\n    }\n    if (isNewExperiment) {\n      postdata.newexperimentname = dsinfo.newexperimentname;\n    } else {\n      postdata.experiment_id = dsinfo.experiment_id;\n    }\n    if (dsinfo.newpiname) {\n      postdata.newpiname = dsinfo.newpiname;\n    } else {\n      postdata.pi_id = isExternal ? dsinfo.pi_id : pdata.internal_pi_id;\n    }\n    if (dsinfo.ptype_id !== pdata.local_ptype_id) {\n      postdata.externalcontact = dsinfo.externalcontactmail;\n    }\n    const response = await postJSON('/datasets/save/project/', postdata);\n    if ('error' in response) {\n      saveerrors.basics = [response.error, ...saveerrors.basics];\n    } else {\n  \t  dataset_id.set(response.dataset_id);\n      console.log($dataset_id);\n      fetchDataset();\n    }\n  }\n}\n\nonMount(async() => {\n  await fetchDataset();\n})\n\nfunction showMetadata() {\n  tabshow = 'meta';\n}\n\nfunction showFiles() {\n  tabshow = $dataset_id ? 'files' : tabshow;\n}\n\n</script>\n\n\n<ErrorNotif cssclass=\"sticky\" errors={Object.values(saveerrors).flat().concat(Object.values(errors).flat())} />\n<!--\n{#if Object.values(errors).flat().length || Object.values(saveerrors).flat().length}\n<div class=\"notification errorbox is-danger\">\n  <ul>\n    {#each Object.values(saveerrors).flat() as error}\n    <li>&bull; {error}</li>\n    {/each}\n    {#each Object.values(errors).flat() as error}\n    <li>&bull; {error}</li>\n    {/each}\n  </ul>\n</div>\n{/if}\n-->\n\n<div class=\"tabs is-toggle is-centered is-small\">\n\t<ul>\n    <li class={tabshow === 'meta' ? 'is-active': ''}><a on:click={showMetadata}>\n        <span>Metadata</span>\n    </li>\n    {#if $dataset_id}\n    <li class={tabshow === 'files' ? 'is-active': ''}><a on:click={showFiles}>\n        <span>Files</span>\n    </li>\n    {/if}\n\t</ul>\n</div>\n\n<h4 class=\"title is-4\">Dataset</h4> \n<div style=\"display: {tabshow !== 'meta' ? 'none' : ''}\">\n    <div class=\"box\" id=\"project\">\n    \n      {#if dsinfo.storage_location}\n    \t<article class=\"message is-info\"> \n        <div class=\"message-header\">Storage location</div>\n        <div class=\"message-body\">{dsinfo.storage_location}</div>\n    \t</article>\n      {/if}\n    \n      <h5 class=\"has-text-primary title is-5\">\n        {#if stored}\n        <i class=\"icon fas fa-check-circle\"></i>\n        {/if}\n        Basics\n        <button class=\"button is-small is-danger has-text-weight-bold\" disabled={!edited} on:click={save}>Save</button>\n        <button class=\"button is-small is-info has-text-weight-bold\" disabled={!edited || !dsinfo.datatype_id} on:click={fetchDataset}>Revert</button>\n      </h5>\n    \n      <div class=\"field\"> \n        <label class=\"label\">Project\n        {#if isNewProject}\n        <span class=\"tag is-danger is-outlined is-small\">New project</span>\n        {#if $dataset_id}\n        <span class=\"tag is-danger is-outlined is-small\">Are you sure?</span>\n        {/if}\n        {/if}\n        </label>\n        <div class=\"control\">\n          <DynamicSelect bind:intext={dsinfo.project_name} fixedoptions={pdata.projects} bind:unknowninput={dsinfo.newprojectname} bind:selectval={dsinfo.project_id} on:selectedvalue={e => project_selected()} on:newvalue={setNewProj} niceName={x => x.name}/>\n        {#if isNewProject}\n        <label class=\"label\">Project type</label>\n        <div class=\"select\">\n          <select bind:value={dsinfo.ptype_id}>\n            <option disabled value=\"\">Please select one</option>\n            {#each pdata.ptypes as ptype}\n            <option value={ptype.id}>{ptype.name}</option>\n            {/each}\n          </select>\n        </div>\n        {/if}\n\n        {#if isExternal}\n        <span class=\"tag is-success is-medium\">External project: {dsinfo.pi_name}</span>\n        {/if}\n        </div>\n      </div>\n\n      {#if isExternal}\n      <div class=\"field\">\n        <label class=\"label\">contact(s)\n        {#if dsinfo.newpiname}\n        <span class=\"tag is-danger is-outlined is-small\">New PI</span>\n        {/if}\n        <div class=\"control\">\n          {#if isNewProject}\n          <DynamicSelect bind:intext={dsinfo.pi_name} fixedoptions={pdata.external_pis} bind:unknowninput={dsinfo.newpiname} bind:selectval={dsinfo.pi_id} niceName={x => x.name} />\n          {/if}\n          <input class=\"input\" type=\"text\" on:change={editMade} bind:value={dsinfo.externalcontactmail} placeholder=\"operational contact email (e.g. postdoc)\">\n        </div>\n      </div>\n      {/if}\n    \n      <div class=\"field\">\n        <label class=\"label\">Dataset type</label>\n        <div class=\"control\">\n          <div class=\"select\">\n            <select bind:value={dsinfo.datatype_id} on:change={switchDatatype}>\n              <option disabled value=\"\">Please select one</option>\n              {#each pdata.datasettypes as dstype}\n              <option value={dstype.id}>{dstype.name}</option>\n              {/each}\n            </select>\n          </div>\n        </div>\n      </div>\n\n      {#if !isLabelcheck}\n      <div class=\"field\">\n        <label class=\"label\">Experiment name\n          <a class=\"button is-danger is-outlined is-small\" on:click={e => isNewExperiment = isNewExperiment === false}>\n          {#if isNewExperiment}\n          Existing experiment\n          {:else}\n          Create new experiment\n          {/if}\n          </a>\n        </label>\n        <div class=\"control\">\n          {#if isNewExperiment}\n          <input class=\"input\" bind:value={dsinfo.newexperimentname} on:change={editMade} type=\"text\" placeholder=\"Experiment name\">\n          {:else}\n          <div class=\"select\">\n            <select bind:value={dsinfo.experiment_id} on:change={editMade}>\n              <option disabled value=\"\">Please select one</option>\n              {#each experiments as exp}\n              <option value={exp.id}>{exp.name}</option>\n              {/each}\n            </select>\n          </div>\n          {/if}\n        </div>\n      </div>\n      {/if}\n  \n      {#if showMsdata}\n      <Msdata bind:this={mssubcomp} on:edited={editMade} bind:dsinfo={dsinfo} prefracs={pdata.prefracs} hirief_ranges={pdata.hirief_ranges} />\n\n      <div class=\"field\">\n        <label class=\"label\">Run name</label>\n        <div class=\"control\">\n          <input class=\"input\" bind:value={dsinfo.runname} on:change={editMade} type=\"text\" placeholder=\"E.g set1, lc3, rerun5b, etc\">\n        </div>\n      </div>\n\n      <Acquicomp bind:this={acquicomp} bind:errors={errors.acqui} />\n      {:else if dsinfo.datatype_id}\n      <div class=\"field\">\n        <label class=\"label\">Run name</label>\n        <div class=\"control\">\n          <input class=\"input\" bind:value={dsinfo.runname} on:change={editMade} type=\"text\" placeholder=\"E.g set1, lc3, rerun5b, etc\">\n        </div>\n      </div>\n      {/if}\n      {#if (components.indexOf('sampleprep')> -1)}\n      <Prepcomp bind:this={prepcomp} bind:errors={errors.sprep} />\n      {/if}\n      {#if (Object.keys($datasetFiles).length && components.indexOf('labelchecksamples')>-1)}\n      <LCheck bind:this={lccomp} bind:errors={errors.lc} />\n      {:else if (Object.keys($datasetFiles).length && components.indexOf('pooledlabelchecksamples')>-1)}\n      <PooledLCheck bind:this={pooledlc} bind:errors={errors.lc} />\n      {/if}\n    </div>\n</div>\n\n<div style=\"display: {tabshow !== 'files' ? 'none' : ''}\">\n    <Files bind:this={filescomp} />\n</div>\n","import App from './App.svelte';\n\nvar app = new App({\n\ttarget: document.querySelector('#appbox')\n});\n\nexport default app;\n"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","component_subscribe","component","store","callback","$$","on_destroy","push","unsub","subscribe","unsubscribe","null_to_empty","value","set_store_value","ret","set","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","i","length","d","element","name","document","createElement","text","data","createTextNode","space","empty","listen","event","handler","options","addEventListener","removeEventListener","stop_propagation","stopPropagation","call","this","attr","attribute","removeAttribute","setAttribute","to_number","undefined","set_data","set_input_value","input","set_style","key","important","style","setProperty","select_option","select","option","__value","selected","select_value","selected_option","querySelector","current_component","set_current_component","onMount","Error","get_current_component","on_mount","createEventDispatcher","type","detail","callbacks","e","createEvent","initCustomEvent","custom_event","slice","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","add_flush_callback","flush","seen_callbacks","Set","shift","update","pop","has","add","fragment","dirty","before_update","p","ctx","after_update","outroing","outros","group_outros","r","c","check_outros","transition_in","block","local","delete","transition_out","o","globals","window","global","bind","props","indexOf","bound","mount_component","m","new_on_destroy","map","filter","destroy_component","make_dirty","then","init","instance","create_fragment","not_equal","prop_names","parent_component","context","Map","ready","hydrate","l","Array","from","childNodes","intro","SvelteComponent","[object Object]","$destroy","index","splice","async","parseResponse","response","jsonresp","json","error","ok","status","getJSON","url","fetch","postJSON","postdata","method","headers","Content-Type","body","JSON","stringify","subscriber_queue","writable","start","stop","subscribers","new_value","run_queue","s","invalidate","subscriber","dataset_id","datasetFiles","projsamples","param","fields","placeholder","edited","model","checked","title","inputtype","dispatch","errors","cssclass","operator","id","editMade","dsinfo","rp_length","stored","acquierrors","acqdata","operators","dynamic_rp","entries","params","operator_id","save","fetchData","validate","comperrors","$dataset_id","val","message","optorder","niceName","optid","hoveropt","mouseup_handler","mousemove_handler","inputdone","handleKeyInput","preventDefault","starttyping","intext","typing","optorderindex","selectval","fixedoptions","fixedorder","fetchUrl","fetchedData","unknowninput","mouseSelect","initval","console","log","selectvalue","fromEntries","x","ix","keyCode","assign","keys","toLowerCase","toString","niceSpecies","spec","click_handler","prepdata","enzymes","enzyme","quant","isLabelfree","labelfree_multisample","foundNewSamples","$datasetFiles","parseSampleNames","trysamplenames","checkIfNewSamples","saveNewSamples","labelfree_singlesample","newprojsample","values","quants","quanttype","chans","sample","s_id","file","samples","associd","change_handler_2","change_handler_3","channel","change_handler","change_handler_1","preperrors","allspecies","sort","func","func_1","selectedspecies","fetchedSpecies","addOrganism","species","no_enzyme","nice","linnean","labelfree_quant_id","removeOrganism","org_id","some","ch","checkNewSampleLabelfree","uppername","trim","toUpperCase","found","checkNewSampleIso","chanix","resetNewSampleName","chan_or_sample","doSampleSave","ch_or_samfn","samplename","psid","psname","f","Number","assocs","checkSamplesIfNewFiles","ixmap","fnmap","line","split","nps","aid","saves","savedsample","samfn","item","labelfree","filenames","prefrac","prefrac_length","hirief_ranges","hiriefrange","range","prefrac_amount","prefracs","hiriefselected","prefrac_id","pf","lcdata","badChannel","channelname","chanorder","lcerrors","okChannel","fid","checkNewSample","parseInt","isoTime","date","size","instrument","click_handler_4","files","newfn_order","selectedFiles","dsfn_order","removed_files","addedFiles","ok_files","outside_files","changed","findFiles","fetchFiles","addFiles","selectAllNew","findQuery","allNewSelector","timestamp","Date","toISOString","newFiles","sortkey","sortascending","reSort","deleteFile","fnid","concat","join","select_state","added_files","tabshow","showFiles","storage_location","pdata","ptypes","ptype_id","ptype","pi_name","externalcontactmail","newpiname","isNewProject","external_pis","pi_id","dstype","isNewExperiment","experiments","experiment_id","newexperimentname","exp","runname","acqui","sprep","lc","components","saveerrors","flat","projects","project_name","newprojectname","project_id","setNewProj","datasettypes","isLabelcheck","showMsdata","datatype_id","showMetadata","fetchDataset","switchDatatype","isExternal","mssubcomp","acquicomp","prepcomp","lccomp","pooledlc","filescomp","init_dataset_id","basics","old_project_id","oldnewprojectname","local_ptype_id","getcomponents","result","project_selected","saved","projdata","re","RegExp","test","internal_pi_id","mserrors","externalcontact"],"mappings":"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"}